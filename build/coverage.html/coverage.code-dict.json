{"/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/test.js":"/* istanbul instrument in package npmtest_websockets_streaming_audio */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/lib.npmtest_websockets_streaming_audio.js":"/* istanbul instrument in package npmtest_websockets_streaming_audio */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_websockets_streaming_audio = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_websockets_streaming_audio = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-websockets-streaming-audio && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_websockets_streaming_audio */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_websockets_streaming_audio\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_websockets_streaming_audio.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_websockets_streaming_audio.rollup.js'] =\n            local.assetsDict['/assets.npmtest_websockets_streaming_audio.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_websockets_streaming_audio.__dirname + '/lib.npmtest_websockets_streaming_audio.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/config/config.dev.js":"\nvar config = require('./config.global');\n\nconfig.env = \"dev\";\nconfig.hostname = 'test.example';\n\n//    media_path   <--  a double quote : delimited list of full paths to reach dirs containing \n//                                       audio media files  IE. song files in WAV format\n\nconfig.media_path = \"/home/stens/Dropbox/Documents/data/audio:/some/full/path/to/dir/of/files\";\n\nmodule.exports = config;\n\n\n","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/config/config.global.js":"\n// put global vars here\n\nvar config = module.exports = {};\n\nconfig.env = \"dev\";\nconfig.hostname = \"dev.example.com\";\n\nconfig.absolute_or_relative = \"relative\"; // find below media_dir relative to directory where local_app.js lives\n// config.absolute_or_relative = \"absolute\"; // find below media_dir as an absolute directory path\n\nconfig.media_dir = \"../media\";\n\nconfig.media_path_relative = \"../media\";\nconfig.media_path_absolute = \"/home/stens/Dropbox/Documents/data/audio\";\n\n// config.media_dir = \"/home/stens/Videos/work\";\n\n","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/config/config.prod.js":"\nvar config = require('./config.global');\n\nconfig.env = \"prod\";\n// config.hostname = 'test.example';\n\nmodule.exports = config;\n\n\n","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/src/app.js":"\nvar streaming_audio_server = function() {\n\n\"use strict\";\n\nconsole.log(require('../package.json').name, require('../package.json').version);\n\nvar path = require('path');\n\nvar working_dir = path.join(__dirname, \"/\");\n\nvar working_app = path.join(working_dir, \"local_app\");\n\nconsole.log(\"working_app \", working_app);\n\nvar app_obj = require(working_app);\n\nconsole.log(\"app_obj \", app_obj);\n\napp_obj.launch_server(working_dir);\n\n// -----------------------------------------------------------------------  //\n\n}(); //  streaming_audio_server = function()\n\n","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/src/local_app.js":"\nvar launch_server = function(working_dir) {\n\n\"use strict\";\n\nconsole.log(\"TOP of launch_server\");\n\nconsole.log(require('../package.json').name, require('../package.json').version);\n\nvar server_streaming_audio = require(\"./server_streaming_audio.js\");\n\nconsole.log(\"server_streaming_audio \", server_streaming_audio);\n\n\nvar WebSocketServer = require(\"ws\").Server;\nvar http = require(\"http\");\nvar express = require(\"express\");\nvar app = express();\nvar port = process.env.PORT || 8888;\n\n// ---\n\nvar cfg = require(\"../config\");\n\nvar media_dir = cfg.media_dir;\n\nconsole.log(\"here is media_dir \", media_dir);\n\nserver_streaming_audio.set_media_dir(media_dir);\n\n\n\nvar media_path = cfg.media_path;\n\nconsole.log(\"here is media_path \", media_path);\n\nserver_streaming_audio.set_media_path(media_path);\n\n\n\n// ---\n\napp.use(express.static(working_dir)); // stens TODO - need to handle 404 file NOT found esp wav file\n\nvar server = http.createServer(app);\n\nserver.listen(port);\n\nconsole.log(\"http server listening on %d\", port);\n\n\n\nconsole.log(\"about to call new WebSocketServer\");\n\nvar wss = new WebSocketServer({\n    server: server\n});\n\nconsole.log(\"websocket server created\");\n\n\n\nwss.on(\"headers\", function (headers) {\n\n    for (var curr_property in headers) {\n\n        if (headers.hasOwnProperty(curr_property)) {\n\n            console.log(\"headers property \" + curr_property + \" -->\" + headers[curr_property] +\n                \"<-- \");\n        }\n    }\n});\n\n\n\n\nwss.on(\"error\", function (error) {\n\n    console.error(\"ERROR - seeing fault on WebSocketServer : \");\n\n    for (var curr_property in error) {\n\n        if (error.hasOwnProperty(curr_property)) {\n\n            console.log(\"error property \" + curr_property + \" -->\" + error[curr_property] +\n                \"<-- \");\n        }\n    }\n});\n\n\n\nwss.on(\"connection\", function(ws) {\n\n    console.log(\"OK cool ... just opened up a client connection ...\");\n\n    var ID_timeout;\n    (function run() {  //  run immediately ... then repeat after delay\n\n        console.log(process.memoryUsage());\n\n        ws.send(JSON.stringify(process.memoryUsage()), function() {});\n\n        // ID_timeout = setTimeout(run, 60000);\n        ID_timeout = setTimeout(run, 360000);\n    }());\n\n    console.log(\"websocket connection open\");\n\n\n    ws.on(\"message\", function(received_data) {\n\n        // console.log(\"\\n\\nReceived message --------------------\" + received_data);\n\n        var received_json;\n\n        try {\n\n            received_json = JSON.parse(received_data);\n\n        } catch (error) {\n\n            var error_msg = \"ERROR - received NON JSON message -->\" + error + \"<--\" +\n                            \"received_data : \" + received_data;\n\n            console.error(error_msg);\n            return;\n        }\n\n        server_streaming_audio.route_msg(received_json, ws);\n    });\n\n    // ---\n\n    ws.on(\"error\", function(event) {\n\n        var error_msg = \"ERROR on on on error : \" + event;\n        console.error(error_msg);\n    });\n\n    // ---\n\n    ws.on(\"close\", function() {\n\n        console.log(\"websocket connection close\");\n        clearTimeout(ID_timeout);\n    });\n});\n\n};      //      launch_server\n\nexports.launch_server = launch_server;\n\n\n","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/src/server_streaming_audio.js":"\n\nvar server_streaming_audio = (function () {\n\n\"use strict\";\n\nvar fs   = require('fs');\nvar path = require('path');\n\n// ---\n\nvar shared_utils = require(\"shared-utils\");\n\n// --------------------------------------------------------  //\n\nvar request_status;\n\n// -------------------------------------------------------- //\n\n// var BUFFER_SIZE_STREAMING; // size of buffer sent from server to client per callback cycle\n\n// var temp_stream_chunk_obj = {};\n// var limit_buffer_size;\n\nvar stream_status_prior = \"prior\";\nvar stream_status_populated = \"populated\";\nvar stream_status_complete = \"complete\";\n\nvar streaming_buffer_obj = {\n\n    curr_state : stream_status_prior,\n    index_stream : 0\n};\n\nvar request_number = 0;\nvar previous_request_number = 0;\n\nvar request_new = \"request_new\";\nvar request_ongoing = \"request_ongoing\";\nvar header_chunk_size = 44;\n\n// var flag_active = true;\n\n// ---\n\nvar media_dir = null;\nvar set_media_dir = function(given_media_dir) {\n\n    media_dir = given_media_dir;\n};\nexports.set_media_dir = set_media_dir;\n\n// ---\n\nvar media_path = null;\nvar set_media_path = function(given_media_path) {\n\n    media_path = given_media_path;\n};\nexports.set_media_path = set_media_path;\n\n\n// ---\n\nvar streaming_is_done = function (given_max_index, curr_ws) {\n\n    console.log(\"TOOOP streaming_is_done  ... given_max_index \", given_max_index);\n    console.log(\"TOOOP streaming_is_done  ... given_max_index \", given_max_index);\n    console.log(\"TOOOP streaming_is_done  ... given_max_index \", given_max_index);\n\n    var streaming_is_done_msg = {\n\n        streaming_is_done : \"yes\",\n        max_index : given_max_index\n    };\n\n    console.log(\"SEND -------- json DONE --------\");\n    console.log(\"SEND ---------- streaming_is_done_msg \", streaming_is_done_msg);\n    console.log(\"SEND -------- json DONE --------\");\n\n    curr_ws.send(JSON.stringify(streaming_is_done_msg), {binary: false, mask: false});  //  json message\n\n    // --- reset state in prep for followon request\n\n    // curr_stream_session = null;\n\n    file_manager.close();\n\n    // bbbbbbbbbbbbbbb\n\n    previous_request_number = request_number;\n};\n\n// ---\n\nvar send_client_source_data_info = function (audio_obj, curr_websocket) {\n\n    var curr_property;\n    var all_property_tags = {};\n\n    for (curr_property in audio_obj) {\n\n        if (curr_property === \"buffer\") {\n\n            continue;\n        }\n\n        all_property_tags[curr_property] = audio_obj[curr_property];\n    }\n\n    // console.log(\"SEND -------- json all property tags --------\");\n    // console.log(\"SEND -------- all_property_tags \", all_property_tags);\n    // console.log(\"SEND -------- json all property tags --------\");\n\n    curr_websocket.send(JSON.stringify(all_property_tags), {binary: false, mask: false});\n};\n\n// ---\n\nvar stop_streaming = function(received_json, curr_ws) {\n\n    streaming_is_done(0, curr_ws);\n};\n\n// ---\n\nfunction stream_file_into_socket (received_json, curr_ws) {\n\n    var read_stream;\n\n    var curr_index = 0;\n\n    var temp_stream_chunk_obj = {};\n\n    // console.log(\"stream_file_into_socket \");\n\n    var flag_active = true;\n\n    var do_stream = function(header_obj, requested_input_filename, received_json, curr_ws) {\n\n        console.log(\"about to stream ... requested_input_filename \", requested_input_filename);\n\n        var total_media_size;\n        var num_read_send_gulps = 0;\n        var num_bytes_sent = 0;\n\n        // ---\n\n        fs.stat(requested_input_filename, function(error, stat) {\n\n            if (error) { throw error; }\n\n            total_media_size = (stat.size - header_chunk_size) / 2;\n\n            var media_info = {\n                max_index : total_media_size\n            };\n\n            // console.log(\"media_info \", media_info);\n\n            // console.log(\"SEND -------- json max_index --------\");\n            // console.log(\"SEND -------- json max_index -------- \", media_info);\n            // console.log(\"SEND -------- json max_index --------\");\n\n            curr_ws.send(JSON.stringify(media_info));\n\n            // ---\n\n            var BUFFER_SIZE_STREAMING = received_json.transmit_chunksize;\n\n            temp_stream_chunk_obj.buffer = new Float32Array(BUFFER_SIZE_STREAMING);\n\n            // ---\n\n            read_stream = fs.createReadStream(requested_input_filename, \n                                {'flags': 'r',\n                                 'mode': '0666', \n                                 'bufferSize': BUFFER_SIZE_STREAMING, // bufferSize is a hint\n                                                                      // not an imperative\n                                                                      // It's up to the operating \n                                                                      // system to honor it\n                                  start : header_chunk_size });\n            // ---\n\n            var read_from_stream = function(socket_conn) {\n\n                var curr_buffer = new Buffer(BUFFER_SIZE_STREAMING);\n\n                while ((curr_buffer = read_stream.read())) {\n\n                    var fresh_data_buffer = shared_utils.convert_16_bit_signed_int_to_32_bit_float(curr_buffer);\n\n                    temp_stream_chunk_obj.buffer.set(fresh_data_buffer);\n\n                    if (fresh_data_buffer.length < temp_stream_chunk_obj.buffer.length) {\n\n                        // console.log(\"about to zero pad buffer since source only partially fills\");\n\n                        var pad_index = fresh_data_buffer.length;\n                        var pad_max = temp_stream_chunk_obj.buffer.length;\n                        for (; pad_index < pad_max; pad_index += 1) {\n\n                            temp_stream_chunk_obj.buffer[pad_index] = 0;\n                        }\n                    }\n\n                    curr_index += curr_buffer.length;\n                }\n\n                // ---\n\n                // for (var index = 0; index < 4; index += 1) {\n\n                //     console.log(temp_stream_chunk_obj.buffer[index]);\n                // }\n\n                // ---\n\n                num_read_send_gulps += 1;\n                num_bytes_sent += temp_stream_chunk_obj.buffer.length;\n\n                console.log(\"\", (100 * num_bytes_sent / total_media_size).toFixed(2), \n                            \" % sent      num_bytes_sent \", num_bytes_sent, \n                            \" out of \", total_media_size, \" ----------\" );\n\n                // console.log(\"SEND -------- bin read_from_stream -------- length \", temp_stream_chunk_obj.buffer.length);\n                // shared_utils.show_object(temp_stream_chunk_obj, \"temp_stream_chunk_obj\", \"total\", 10);\n                // console.log(\"SEND -------- bin read_from_stream --------\");\n\n                // stens TODO 20150115\n                socket_conn.send(temp_stream_chunk_obj.buffer, {binary: true, mask: false}); // binary buffer\n\n                // below error happens if we use below parms to send\n                // WebSocket connection to 'ws://localhost:8888/' failed: A server must not mask any frames that it sends to the client\n                // socket_conn.send(temp_stream_chunk_obj.buffer, {binary: true, mask: true}); // binary buffer\n\n                flag_active = false;\n\n                read_stream.pause();\n\n            }; // read_from_stream\n\n            // ---\n\n            read_stream.on('readable', function() {\n\n                if (flag_active) {\n\n                    read_from_stream(curr_ws);\n                }\n            });\n\n            read_stream.on('end', function() {\n\n                streaming_is_done(total_media_size, curr_ws);\n\n              // return;\n            });\n        }); \n    };      //      do_stream\n\n    // var init_stream = function(media_dir, received_json, curr_ws, media_filename) {\n\n    var init_stream = function(media_dir, media_path, received_json, curr_ws, media_filename) {\n\n        // stens TODO - search for given media filename across both media_dir as well as\n        //              media_path  ... look at ../config/config.global.js\n        //              in particular both \n        //     config.media_path_relative = \"../media\";\n        //     config.media_path_absolute = \"/home/stens/Dropbox/Documents/data/audio\";\n\n        streaming_buffer_obj = {\n\n            curr_state : stream_status_prior,\n            index_stream : 0\n        };\n\n        // ---\n\n        var requested_input_filename = path.join(__dirname, media_dir, media_filename);\n\n        // console.log(\"requested_input_filename \" + requested_input_filename);\n\n        if (! fs.existsSync(requested_input_filename)) {\n\n            var error_msg = {\n\n                error_msg : \"ERROR - requested file does not exist\",\n                media_filename : media_filename\n\n            };\n\n            console.log(\"SEND -------- json ERROR --------\");\n            console.log(error_msg);\n            curr_ws.send(JSON.stringify(error_msg), {binary: false, mask: false});\n            console.log(\"SEND -------- json ERROR --------\");\n\n            return;\n        }\n\n        // ------------- now parse headers ------------- //\n\n        var wav_input_file_obj = {};\n\n        shared_utils.parse_wav_header(wav_input_file_obj, requested_input_filename, function(error, header_obj) {\n\n            if (error) {\n\n                console.error(error);\n                return;\n\n            } else {\n\n                shared_utils.show_object(header_obj, \"file headers\", \"total\", 3);\n\n                send_client_source_data_info(header_obj, curr_ws);\n\n                do_stream(header_obj, requested_input_filename, received_json, curr_ws);\n            }\n        });\n    };        //      init_stream\n\n    // ---\n\n    var roll_it = function(received_json, curr_ws) {\n\n        flag_active = true;\n\n        read_stream.resume();\n    };\n\n    return {\n\n        // assure ONLY one instance exists and is returned on all calls\n\n        roll_it: roll_it,\n        init_stream : init_stream\n    };\n}       //      stream_file_into_socket\n\n// ---\n\nvar file_manager = (function() {\n\n    var curr_stream_session = null;    //  each streaming file process gets a fresh such closure\n    var media_filename = null;\n\n    return {\n\n        read_file_pop_buffer_stream_back_to_client_async : function(received_json, curr_ws, request_status) {\n\n            if (request_status === request_new) {\n\n                curr_stream_session = null;\n\n                curr_stream_session = stream_file_into_socket(received_json, curr_ws);\n\n                // curr_stream_session.init_stream(media_dir, received_json, curr_ws, media_filename);\n\n                curr_stream_session.init_stream(media_dir, media_path, received_json, curr_ws, media_filename);\n\n            } else {\n\n                if (curr_stream_session) {\n\n                    curr_stream_session.roll_it(received_json, curr_ws);\n                }\n            }\n        },\n        set_media_filename : function(given_media_filename) {\n\n            media_filename = given_media_filename;\n        },\n        get_media_filename : function() {\n\n            return media_filename;\n        },\n        close : function() {\n\n            curr_stream_session = null; // stens TODO do proper fs close or such\n        }\n    };\n}());\n\n// ---\n\nvar route_msg = function(received_json, curr_ws) {\n\n    // shared_utils.show_object(received_json, \"SSSSSSS received_json  \", \"total\", 3);\n\n\n    // console.log(\"received_json\");\n    // console.log(received_json);\n\n\n\n    var requested_action = received_json.requested_action;\n\n    if (typeof requested_action == \"undefined\") {\n\n        console.error(\"ERROR - failed to see property : requested_action in client JSON msg\");\n        // process.exit(8);\n    }\n\n    // ---\n\n    // var putative_request_number = received_json.request_number; // request_number\n\n    if (received_json.request_number === request_number) {\n\n        request_status = request_ongoing;\n\n    } else {\n\n        request_number = received_json.request_number;\n        request_status = request_new;\n\n        var media_filename = received_json.requested_source;\n\n        if (typeof media_filename !== \"undefined\") {\n\n            file_manager.set_media_filename(media_filename);\n\n        } else {\n\n            throw new Error(\"ERROR - failed to supply requested_source\");\n        }\n    }\n\n    // ---\n\n    // bbbbbbbbbbbbb\n\n    switch (requested_action) {\n\n        case \"stream_audio_to_client\" : {\n\n            // console.log(\"RECEIVED ---------- stream_audio_to_client request_status \", request_status);\n            // console.log(\"RECEIVED ---------- stream_audio_to_client request_status \", request_status);\n            // console.log(\"RECEIVED ---------- stream_audio_to_client request_status \", request_status);\n\n            if (request_status === request_ongoing) {\n\n                if (request_number === previous_request_number) {\n\n\n                    // console.log(\"request_status  \" + request_status);\n                    // console.log(\"request_ongoing \" + request_ongoing);\n                    // console.log(\"request_number             \" + request_number);\n                    // console.log(\"previous_request_number    \" + previous_request_number);\n\n\n                    console.log(\"cool we have already stopped this stream request so ignoring stream request\");\n\n                    break;   \n                }\n            }\n\n            // random_delay simulates a poor internet connection between server side and browser\n            // TROUBLESHOOTING ONLY make 0 otherwise\n            // TROUBLESHOOTING ONLY make 0 otherwise\n            // TROUBLESHOOTING ONLY make 0 otherwise\n            // var random_delay = ~~(1200 * Math.random()); // TROUBLESHOOTING ONLY make 0 otherwise\n            // var random_delay = ~~(800 * Math.random()); // TROUBLESHOOTING ONLY make 0 otherwise\n            var random_delay = 0; // use this in prod\n            // TROUBLESHOOTING ONLY make 0 otherwise\n            // TROUBLESHOOTING ONLY make 0 otherwise\n            // TROUBLESHOOTING ONLY make 0 otherwise\n\n            // console.log(\"random_delay \" + random_delay);\n\n            setTimeout(function() {\n\n                file_manager.read_file_pop_buffer_stream_back_to_client_async(\n                                                        received_json, curr_ws, request_status);\n\n            }, random_delay);\n\n            break;\n        }\n\n        case \"stop_streaming\" : {\n\n            // if (request_status === request_ongoing &&\n            //     streaming_buffer_obj.curr_state === stream_status_prior) {\n\n            //     console.log(\"request_status  \" + request_status);\n            //     console.log(\"request_ongoing \" + request_ongoing);\n            //     console.log(\"streaming_buffer_obj.curr_state \" + streaming_buffer_obj.curr_state);\n            //     console.log(\"stream_status_prior             \" + stream_status_prior);\n\n            //     console.log(\"cool we have already stopped this stream request so ignoring stop request\");\n\n            // } else {\n\n                console.log(\"RECEIVED ---------- stop_streaming\");\n                console.log(\"RECEIVED ---------- stop_streaming\");\n                console.log(\"RECEIVED ---------- stop_streaming\");\n\n                stop_streaming(received_json, curr_ws);\n            // }\n\n            break;\n        }\n\n        default : {\n\n            console.error(\"ERROR - failed to recognize client requested_action : \",\n                            requested_action);            \n            // process.exit(8);\n\n            break;\n        }\n    }\n};      //      route_msg\nexports.route_msg = route_msg;\n\n}()); //  server_streaming_audio = function()\n\n\n","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/config/index.js":"\nvar environment_mode = process.env.NODE_ENV || \"dev\",\n\tcfg = require(\"./config.\" + environment_mode);\n\nmodule.exports = cfg;\n\n\n","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/src/app_loki.js":"\nvar streaming_audio_server = function() {\n\n\"use strict\";\n\nconsole.log(require('../package.json').name, require('../package.json').version);\n\nvar path = require('path');\n\nvar working_dir = path.join(__dirname, \"/\");\n\nvar working_app = path.join(working_dir, \"local_app_loki\");\n\nconsole.log(\"working_app \", working_app);\n\nvar app_obj = require(working_app);\n\nconsole.log(\"app_obj \", app_obj);\n\napp_obj.launch_server(working_dir);\n\n// -----------------------------------------------------------------------  //\n\n}(); //  streaming_audio_server = function()\n\n","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/src/local_app_loki.js":"\nvar launch_server = function(working_dir) {\n\n\"use strict\";\n\nconsole.log(\"TOP of launch_server\");\n\nconsole.log(require('../package.json').name, require('../package.json').version);\n\n// var server_streaming_audio = require(\"./server_streaming_audio.js\");\nvar server_streaming_audio = require(\"./server_loki.js\");\n\nconsole.log(\"server_streaming_audio \", server_streaming_audio);\n\n\nvar WebSocketServer = require(\"ws\").Server;\nvar http = require(\"http\");\nvar express = require(\"express\");\nvar app = express();\nvar port = process.env.PORT || 8888;\n\n// ---\n\nvar cfg = require(\"../config\");\n\nvar media_dir = cfg.media_dir;\n\nconsole.log(\"here is media_dir \", media_dir);\n\nserver_streaming_audio.set_media_dir(media_dir);\n\n\n\nvar media_path = cfg.media_path;\n\nconsole.log(\"here is media_path \", media_path);\n\nserver_streaming_audio.set_media_path(media_path);\n\n\n\n// ---\n\napp.use(express.static(working_dir)); // stens TODO - need to handle 404 file NOT found esp wav file\n\nvar server = http.createServer(app);\n\nserver.listen(port);\n\nconsole.log(\"http server listening on %d\", port);\n\n\n\nconsole.log(\"about to call new WebSocketServer\");\n\nvar wss = new WebSocketServer({\n    server: server\n});\n\nconsole.log(\"websocket server created\");\n\n\n\nwss.on(\"headers\", function (headers) {\n\n    for (var curr_property in headers) {\n\n        if (headers.hasOwnProperty(curr_property)) {\n\n            console.log(\"headers property \" + curr_property + \" -->\" + headers[curr_property] +\n                \"<-- \");\n        }\n    }\n});\n\n\n\n\nwss.on(\"error\", function (error) {\n\n    console.error(\"ERROR - seeing fault on WebSocketServer : \");\n\n    for (var curr_property in error) {\n\n        if (error.hasOwnProperty(curr_property)) {\n\n            console.log(\"error property \" + curr_property + \" -->\" + error[curr_property] +\n                \"<-- \");\n        }\n    }\n});\n\n\n\nwss.on(\"connection\", function(ws) {\n\n    console.log(\"OK cool ... just opened up a client connection ...\");\n\n    var ID_timeout;\n    (function run() {  //  run immediately ... then repeat after delay\n\n        console.log(process.memoryUsage());\n\n        ws.send(JSON.stringify(process.memoryUsage()), function() {});\n\n        // ID_timeout = setTimeout(run, 60000);\n        ID_timeout = setTimeout(run, 360000);\n    }());\n\n    console.log(\"websocket connection open\");\n\n\n    ws.on(\"message\", function(received_data) {\n\n        // console.log(\"\\n\\nReceived message --------------------\" + received_data);\n\n        var received_json;\n\n        try {\n\n            received_json = JSON.parse(received_data);\n\n        } catch (error) {\n\n            var error_msg = \"ERROR - received NON JSON message -->\" + error + \"<--\" +\n                            \"received_data : \" + received_data;\n\n            console.error(error_msg);\n            return;\n        }\n\n        server_streaming_audio.route_msg(received_json, ws);\n    });\n\n    // ---\n\n    ws.on(\"error\", function(event) {\n\n        var error_msg = \"ERROR on on on error : \" + event;\n        console.error(error_msg);\n    });\n\n    // ---\n\n    ws.on(\"close\", function() {\n\n        console.log(\"websocket connection close\");\n        clearTimeout(ID_timeout);\n    });\n});\n\n};      //      launch_server\n\nexports.launch_server = launch_server;\n\n\n","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/src/server_loki.js":"\n\nvar server_streaming_audio = (function () {\n\n\"use strict\";\n\nvar fs   = require('fs');\nvar path = require('path');\n\n// ---\n\nvar shared_utils = require(\"shared-utils\");\n\n// --------------------------------------------------------  //\n\nvar request_status;\n\n// -------------------------------------------------------- //\n\n// var BUFFER_SIZE_STREAMING; // size of buffer sent from server to client per callback cycle\n\n// var temp_stream_chunk_obj = {};\n// var limit_buffer_size;\n\nvar stream_status_prior = \"prior\";\nvar stream_status_populated = \"populated\";\nvar stream_status_complete = \"complete\";\n\nvar streaming_buffer_obj = {\n\n    curr_state : stream_status_prior,\n    index_stream : 0\n};\n\nvar request_number = 0;\nvar previous_request_number = 0;\n\nvar request_new = \"request_new\";\nvar request_ongoing = \"request_ongoing\";\nvar header_chunk_size = 44;\n\n// var flag_active = true;\n\n// ---\n\nvar media_dir = null;\nvar set_media_dir = function(given_media_dir) {\n\n    media_dir = given_media_dir;\n};\nexports.set_media_dir = set_media_dir;\n\n// ---\n\nvar media_path = null;\nvar set_media_path = function(given_media_path) {\n\n    media_path = given_media_path;\n};\nexports.set_media_path = set_media_path;\n\n\n// ---\n\nvar streaming_is_done = function (given_max_index, curr_ws) {\n\n    console.log(\"TOOOP streaming_is_done  ... given_max_index \", given_max_index);\n    console.log(\"TOOOP streaming_is_done  ... given_max_index \", given_max_index);\n    console.log(\"TOOOP streaming_is_done  ... given_max_index \", given_max_index);\n\n    var streaming_is_done_msg = {\n\n        streaming_is_done : \"yes\",\n        max_index : given_max_index\n    };\n\n    console.log(\"SEND -------- json DONE --------\");\n    console.log(\"SEND ---------- streaming_is_done_msg \", streaming_is_done_msg);\n    console.log(\"SEND -------- json DONE --------\");\n\n    curr_ws.send(JSON.stringify(streaming_is_done_msg), {binary: false, mask: false});  //  json message\n\n    // --- reset state in prep for followon request\n\n    // curr_stream_session = null;\n\n    file_manager.close();\n\n    // bbbbbbbbbbbbbbb\n\n    previous_request_number = request_number;\n};\n\n// ---\n\nvar send_client_source_data_info = function (audio_obj, curr_websocket) {\n\n    var curr_property;\n    var all_property_tags = {};\n\n    for (curr_property in audio_obj) {\n\n        if (curr_property === \"buffer\") {\n\n            continue;\n        }\n\n        all_property_tags[curr_property] = audio_obj[curr_property];\n    }\n\n    console.log(\"SEND -------- json all property tags --------\");\n    console.log(\"SEND -------- all_property_tags \", all_property_tags);\n    console.log(\"SEND -------- json all property tags --------\");\n\n    curr_websocket.send(JSON.stringify(all_property_tags), {binary: false, mask: false});\n};\n\n// ---\n\nvar stop_streaming = function(received_json, curr_ws) {\n\n    streaming_is_done(0, curr_ws);\n};\n\n// ---\n\nfunction stream_file_into_socket (received_json, curr_ws) {\n\n    var read_stream;\n\n    var curr_index = 0;\n\n    var temp_stream_chunk_obj = {};\n\n    // console.log(\"stream_file_into_socket \");\n\n    var flag_active = true;\n\n    var do_stream = function(header_obj, requested_input_filename, received_json, curr_ws) {\n\n        console.log(\"about to stream ... requested_input_filename \", requested_input_filename);\n\n        var total_media_size;\n        var num_read_send_gulps = 0;\n        var num_bytes_sent = 0;\n\n        // ---\n\n        fs.stat(requested_input_filename, function(error, stat) {\n\n            if (error) { throw error; }\n\n            total_media_size = (stat.size - header_chunk_size) / 2;\n\n            var media_info = {\n                max_index : total_media_size\n            };\n\n            // console.log(\"media_info \", media_info);\n\n            console.log(\"SEND -------- json media_info --------\");\n            console.log(\"SEND -------- json media_info -------- \", media_info);\n            console.log(\"SEND -------- json media_info --------\");\n\n            curr_ws.send(JSON.stringify(media_info));\n\n            // ---\n\n            var BUFFER_SIZE_STREAMING = received_json.transmit_chunksize;\n\n            temp_stream_chunk_obj.buffer = new Float32Array(BUFFER_SIZE_STREAMING);\n\n            // ---\n\n            read_stream = fs.createReadStream(requested_input_filename, \n                                {'flags': 'r',\n                                 'mode': '0666', \n                                 'bufferSize': BUFFER_SIZE_STREAMING, // bufferSize is a hint\n                                                                      // not an imperative\n                                                                      // It's up to the operating \n                                                                      // system to honor it\n                                  start : header_chunk_size });\n            // ---\n\n            var read_from_stream = function(socket_conn) {\n\n                var curr_buffer = new Buffer(BUFFER_SIZE_STREAMING);\n\n                while ((curr_buffer = read_stream.read())) {\n\n                    var fresh_data_buffer = shared_utils.convert_16_bit_signed_int_to_32_bit_float(curr_buffer);\n\n                    temp_stream_chunk_obj.buffer.set(fresh_data_buffer);\n\n                    if (fresh_data_buffer.length < temp_stream_chunk_obj.buffer.length) {\n\n                        // console.log(\"about to zero pad buffer since source only partially fills\");\n\n                        var pad_index = fresh_data_buffer.length;\n                        var pad_max = temp_stream_chunk_obj.buffer.length;\n                        for (; pad_index < pad_max; pad_index += 1) {\n\n                            temp_stream_chunk_obj.buffer[pad_index] = 0;\n                        }\n                    }\n\n                    curr_index += curr_buffer.length;\n                }\n\n                num_read_send_gulps += 1;\n                num_bytes_sent += temp_stream_chunk_obj.buffer.length;\n\n                console.log(\"\", (100 * num_bytes_sent / total_media_size).toFixed(2), \n                            \" % sent      num_bytes_sent \", num_bytes_sent, \n                            \" out of \", total_media_size, \" ----------\" );\n\n                console.log(\"SEND -------- bin read_from_stream -------- length \", temp_stream_chunk_obj.buffer.length);\n                shared_utils.show_object(temp_stream_chunk_obj, \"temp_stream_chunk_obj\", \"total\", 10);\n                console.log(\"SEND -------- bin read_from_stream --------\");\n\n                socket_conn.send(temp_stream_chunk_obj.buffer, {binary: true, mask: false}); // binary buffer\n\n                flag_active = false;\n\n                read_stream.pause();\n\n            }; // read_from_stream\n\n            // ---\n\n            read_stream.on('readable', function() {\n\n                if (flag_active) {\n\n                    read_from_stream(curr_ws);\n                }\n            });\n\n            read_stream.on('end', function() {\n\n                streaming_is_done(total_media_size, curr_ws);\n\n              // return;\n            });\n        }); \n    };      //      do_stream\n\n    // var init_stream = function(media_dir, received_json, curr_ws, media_filename) {\n\n    var init_stream = function(media_dir, media_path, received_json, curr_ws, media_filename) {\n\n        // stens TODO - search for given media filename across both media_dir as well as\n        //              media_path  ... look at ../config/config.global.js\n        //              in particular both \n        //     config.media_path_relative = \"../media\";\n        //     config.media_path_absolute = \"/home/stens/Dropbox/Documents/data/audio\";\n\n        streaming_buffer_obj = {\n\n            curr_state : stream_status_prior,\n            index_stream : 0\n        };\n\n        // ---\n\n        var requested_input_filename = path.join(__dirname, media_dir, media_filename);\n\n        // console.log(\"requested_input_filename \" + requested_input_filename);\n\n        if (! fs.existsSync(requested_input_filename)) {\n\n            var error_msg = {\n\n                error_msg : \"ERROR - requested file does not exist\",\n                media_filename : media_filename\n\n            };\n\n            console.log(\"SEND -------- json ERROR --------\");\n            console.log(error_msg);\n            curr_ws.send(JSON.stringify(error_msg), {binary: false, mask: false});\n            console.log(\"SEND -------- json ERROR --------\");\n\n            return;\n        }\n\n        // ------------- now parse headers ------------- //\n\n        var wav_input_file_obj = {};\n\n        shared_utils.parse_wav_header(wav_input_file_obj, requested_input_filename, function(error, header_obj) {\n\n            if (error) {\n\n                console.error(error);\n                return;\n\n            } else {\n\n                shared_utils.show_object(header_obj, \"file headers\", \"total\", 3);\n\n                send_client_source_data_info(header_obj, curr_ws);\n\n                do_stream(header_obj, requested_input_filename, received_json, curr_ws);\n            }\n        });\n    };        //      init_stream\n\n    // ---\n\n    var roll_it = function(received_json, curr_ws) {\n\n        flag_active = true;\n\n        read_stream.resume();\n    };\n\n    return {\n\n        // assure ONLY one instance exists and is returned on all calls\n\n        roll_it: roll_it,\n        init_stream : init_stream\n    };\n}       //      stream_file_into_socket\n\n// ---\n\nvar file_manager = (function() {\n\n    var curr_stream_session = null;    //  each streaming file process gets a fresh such closure\n    var media_filename = null;\n\n    return {\n\n        read_file_pop_buffer_stream_back_to_client_async : function(received_json, curr_ws, request_status) {\n\n            if (request_status === request_new) {\n\n                curr_stream_session = null;\n\n                curr_stream_session = stream_file_into_socket(received_json, curr_ws);\n\n                // curr_stream_session.init_stream(media_dir, received_json, curr_ws, media_filename);\n\n                curr_stream_session.init_stream(media_dir, media_path, received_json, curr_ws, media_filename);\n\n            } else {\n\n                if (curr_stream_session) {\n\n                    curr_stream_session.roll_it(received_json, curr_ws);\n                }\n            }\n        },\n        set_media_filename : function(given_media_filename) {\n\n            media_filename = given_media_filename;\n        },\n        get_media_filename : function() {\n\n            return media_filename;\n        },\n        close : function() {\n\n            curr_stream_session = null; // stens TODO do proper fs close or such\n        }\n    };\n}());\n\n// ---\n\nvar route_msg = function(received_json, curr_ws) {\n\n    console.log(\"received_json\");\n    console.log(received_json);\n\n    shared_utils.show_object(received_json, \"SSSSSSS received_json  \", \"total\", 3);\n\n    var requested_action = received_json.requested_action;\n\n    if (typeof requested_action == \"undefined\") {\n\n        console.error(\"ERROR - failed to see property : requested_action in client JSON msg\");\n        // process.exit(8);\n    }\n\n    // ---\n\n    // var putative_request_number = received_json.request_number; // request_number\n\n    if (received_json.request_number === request_number) {\n\n        request_status = request_ongoing;\n\n    } else {\n\n        request_number = received_json.request_number;\n        request_status = request_new;\n\n        var media_filename = received_json.requested_source;\n\n        if (typeof media_filename !== \"undefined\") {\n\n            file_manager.set_media_filename(media_filename);\n\n        } else {\n\n            throw new Error(\"ERROR - failed to supply requested_source\");\n        }\n    }\n\n    // ---\n\n    // bbbbbbbbbbbbb\n\n    switch (requested_action) {\n\n        case \"stream_audio_to_client\" : {\n\n            // console.log(\"RECEIVED ---------- stream_audio_to_client request_status \", request_status);\n            // console.log(\"RECEIVED ---------- stream_audio_to_client request_status \", request_status);\n            // console.log(\"RECEIVED ---------- stream_audio_to_client request_status \", request_status);\n\n            if (request_status === request_ongoing) {\n\n                if (request_number === previous_request_number) {\n\n\n                    // console.log(\"request_status  \" + request_status);\n                    // console.log(\"request_ongoing \" + request_ongoing);\n                    // console.log(\"request_number             \" + request_number);\n                    // console.log(\"previous_request_number    \" + previous_request_number);\n\n\n                    console.log(\"cool we have already stopped this stream request so ignoring stream request\");\n\n                    break;   \n                }\n            }\n\n            // random_delay simulates a poor internet connection between server side and browser\n            // TROUBLESHOOTING ONLY make 0 otherwise\n            // TROUBLESHOOTING ONLY make 0 otherwise\n            // TROUBLESHOOTING ONLY make 0 otherwise\n            // var random_delay = ~~(1200 * Math.random()); // TROUBLESHOOTING ONLY make 0 otherwise\n            // var random_delay = ~~(800 * Math.random()); // TROUBLESHOOTING ONLY make 0 otherwise\n            var random_delay = 0; // use this in prod\n            // TROUBLESHOOTING ONLY make 0 otherwise\n            // TROUBLESHOOTING ONLY make 0 otherwise\n            // TROUBLESHOOTING ONLY make 0 otherwise\n\n            // console.log(\"random_delay \" + random_delay);\n\n            setTimeout(function() {\n\n                file_manager.read_file_pop_buffer_stream_back_to_client_async(\n                                                        received_json, curr_ws, request_status);\n\n            }, random_delay);\n\n            break;\n        }\n\n        case \"stop_streaming\" : {\n\n            // if (request_status === request_ongoing &&\n            //     streaming_buffer_obj.curr_state === stream_status_prior) {\n\n            //     console.log(\"request_status  \" + request_status);\n            //     console.log(\"request_ongoing \" + request_ongoing);\n            //     console.log(\"streaming_buffer_obj.curr_state \" + streaming_buffer_obj.curr_state);\n            //     console.log(\"stream_status_prior             \" + stream_status_prior);\n\n            //     console.log(\"cool we have already stopped this stream request so ignoring stop request\");\n\n            // } else {\n\n                console.log(\"RECEIVED ---------- stop_streaming\");\n                console.log(\"RECEIVED ---------- stop_streaming\");\n                console.log(\"RECEIVED ---------- stop_streaming\");\n\n                stop_streaming(received_json, curr_ws);\n            // }\n\n            break;\n        }\n\n        default : {\n\n            console.error(\"ERROR - failed to recognize client requested_action : \",\n                            requested_action);            \n            // process.exit(8);\n\n            break;\n        }\n    }\n};      //      route_msg\nexports.route_msg = route_msg;\n\n}()); //  server_streaming_audio = function()\n\n\n","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/src/client_entry.js":"\nvar client_entry = (function() {\n\t\n\"use strict\";\n\n// var ww_handle = new Worker(\"ww_transferable_obj.js\");\n\nwindow.onerror = function(message, url, lineNumber) {  \n\n// https://stackoverflow.com/questions/5328154/catch-all-javascript-errors-and-send-them-to-server\n\n\n    var err_msg = \"\\nERROR - \" + message + \"\\nURL \" + url + \"\\nlineNumber \" + lineNumber;\n    console.log(err_msg);\n    // console.error(err_msg);\n\n    // throw new Error(err_msg);\n\n    return true;\n}; \n\nvar ww_handle = null;\n\ntry {\n\n    ww_handle = new Worker(\"ww_transferable_obj.js\");\n\n} catch(err_event) {\n\n    var err_msg = \"ERROR - failed to create Web Worker : \" + err_event;\n    console.log(err_msg);\n    // console.error(err_msg);\n\n    // throw new Error(err_msg);\n}\n\nvar callback_send_audio_to_audio_player = null;\n// var retrieved_audio_buffer_obj = {};\n\nvar array_stats_for_launch = [];\nvar startTime = 0;\n\nvar manage_state = (function() {\n\n    // (1) initial preload\n    // browser asks ww to get audio from server which gets returned to fill browser queue\n    // ... this is prior to launching web audio API\n    var mode_browser_get_audio_from_server = \"browser_get_audio_from_server\"; // (1)\n    // (1) --> (2) triggered when browser queue becomes full\n\n\n    // (2) server fills up ww queue while browser consumes its own queue undisturbed by server or ww\n    var mode_ww_get_audio_from_server      = \"ww_get_audio_from_server\"; // (2)\n    // (2) --> (3) triggered when browser queue becomes too empty\n\n\n    // (3) ww sends twice as much data to browser as it consumes so browser queue fills - server side idle\n    var mode_browser_get_audio_from_ww     = \"browser_get_audio_from_ww\"; // (3)\n    // (3) --> (2) triggered when browser queue becomes full\n\n\n    var current_browser_mode = mode_browser_get_audio_from_server; // initially state (1) preload browser q\n\n    // --- state transition --- //\n    // \n    //      (1) --> (2) --> (3)  ... loop back to (2)\n\n    // ----------------------------------------------------------------\n\n    var msgs_to_server_by_mode = {};\n\n    return {\n\n        get_state : function() {\n\n            return current_browser_mode;\n        },\n        set_browser_queue_filled : function() {\n\n            // do transition from state (1) OR (3) --> (2)\n\n            if (current_browser_mode === mode_browser_get_audio_from_server ||\n                current_browser_mode === mode_browser_get_audio_from_ww) {\n\n                if (manage_audio.get_is_streaming_done()) {\n\n                    console.log(\"already reached end of source media AND ww queue should be EMPTY \" +\n                        \"\\nso avoid triggering into new state\");\n\n                } else {\n\n                    current_browser_mode = mode_ww_get_audio_from_server; // (1) OR (3) --> (2)\n\n                    console.log(\"new state \" + current_browser_mode + \" ################################### \");\n\n                    ww_handle.postMessage(JSON.stringify(msgs_to_server_by_mode[mode_ww_get_audio_from_server]));\n                }\n\n            } else {\n\n                throw new Error(\"ERROR - was told browser_queue_filled yet \" +\n                                \"current state not (1) or (3) : \" + current_browser_mode);\n            }\n        },\n        set_browser_queue_min_threshold_reached : function() {\n\n            console.log(\"TOP browser_queue_min_threshold_reached\");\n\n            // do transition from (2) --> (3)\n\n            if (current_browser_mode === mode_ww_get_audio_from_server) {\n\n                current_browser_mode = mode_browser_get_audio_from_ww;\n\n                console.log(\"new state \" + current_browser_mode + \" ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \");\n\n                // shared_utils.show_object(msg_curr_mode_3, \"msg_curr_mode_3\", \"total\", 10);\n\n                ww_handle.postMessage(JSON.stringify(msgs_to_server_by_mode[mode_browser_get_audio_from_ww]));\n            }\n        },\n        is_early_days : function() {\n\n            return (current_browser_mode === mode_browser_get_audio_from_server);\n        },\n        request_another_buffer : function() {\n\n            // console.log(\"request_another_buffer \" + manage_state.get_state());\n\n            if (current_browser_mode !== mode_ww_get_audio_from_server) {\n\n                var returned_msg = manage_state.get_msg_to_server_by_mode(manage_state.get_state());\n\n                ww_handle.postMessage(JSON.stringify(returned_msg));\n            }\n        },\n        set_msg_to_server_by_mode : function(given_mode, given_msg) {\n\n            // setup msgs to server for all 3 modes\n\n            msgs_to_server_by_mode[mode_browser_get_audio_from_server] = given_msg;\n            msgs_to_server_by_mode[mode_ww_get_audio_from_server] = {};\n            msgs_to_server_by_mode[mode_browser_get_audio_from_ww] = {};\n\n            var arr_other_modes = [];\n\n            arr_other_modes.push(mode_ww_get_audio_from_server);\n            arr_other_modes.push(mode_browser_get_audio_from_ww);\n\n            for (var curr_mode in arr_other_modes) {\n\n                if (arr_other_modes.hasOwnProperty(curr_mode)) {\n\n                    for (var curr_property in given_msg) {\n\n                        msgs_to_server_by_mode[arr_other_modes[curr_mode]][curr_property] = given_msg[curr_property];\n                    }\n                }\n            }\n\n            msgs_to_server_by_mode[mode_ww_get_audio_from_server].browser_directed_mode = mode_ww_get_audio_from_server;\n            msgs_to_server_by_mode[mode_browser_get_audio_from_ww].browser_directed_mode = mode_browser_get_audio_from_ww;\n        },\n        get_msg_to_server_by_mode : function(given_mode) {\n\n            return msgs_to_server_by_mode[given_mode];\n        }\n    };\n}());   //      manage_state\n\nfunction browser_queue_is_full_callback() {\n\n    console.log(\"AAAAAAAAAAAAAAAAbout to call manage_state.set_browser_queue_filled\");\n\n    manage_state.set_browser_queue_filled();\n}\n\nfunction cb_browser_queue_min_reached() {\n\n    manage_state.set_browser_queue_min_threshold_reached();\n}\n\nvar cb_request_another_buffer = (function() { // stens TODO - remove this as it just limits calls for ts\n\n    var count_requests = 0;\n    // var max_requests = 999999; // limit only to ease troubleshooting\n    var max_requests = 0; // limit only to ease troubleshooting ... set to 0 to ignore\n\n    return function(given_source) {\n\n        if (max_requests === 0 || count_requests < max_requests) {\n\n            // if (manage_state.is_early_days()) { // \n            if (((given_source === \"early_days\" || \n                  given_source === \"Middleburg\") && manage_audio.get_is_production_possible()) ||\n                  given_source === \"tell_ww_to_refill\") {\n\n                    // console.log(\"cb_request_another_buffer given_source \" + given_source);\n\n                    manage_state.request_another_buffer();\n\n            } else {\n\n                // console.log(\"fat and happy ... queue is full ... Il dolce far niente\");\n            }\n\n        } else {\n\n            throw new Error(\"ERROR - NOTICE - hold your horses ... intentionally stopping\");\n        }\n\n        count_requests += 1;\n    };\n}());\n\nfunction cb_get_is_streaming_done() {\n\n    // console.log(\"here is is streaming done \" + manage_audio.get_is_streaming_done());\n\n    return manage_audio.get_is_streaming_done();\n}\n\nfunction output_stored_media() {\n\n    send_audio_to_server.output_media();\n}\n\nvar manage_audio = (function() {\n\n\tvar web_audio_obj = Object.create(render_streaming_web_audio());\n\n\tcallback_send_audio_to_audio_player = web_audio_obj.cb_send_buffer_to_web_audio_player;\n\n    // define callback so audio processing can execute web worker request for another buffer\n    web_audio_obj.set_cb_request_another_buffer(cb_request_another_buffer);\n\n    web_audio_obj.queue_first_in_first_out.set_cb_browser_queue_is_full(browser_queue_is_full_callback);\n    web_audio_obj.queue_first_in_first_out.set_cb_browser_queue_min_reached(cb_browser_queue_min_reached);\n    // web_audio_obj.queue_first_in_first_out.set_cb_get_state(cb_get_state);\n\n    web_audio_obj.set_cb_is_streaming_done(cb_get_is_streaming_done);\n\n    var streaming_is_done = false; // did we reach end of source media we are streaming\n                                    // if true we have received last buffer from ww or server\n    var flag_desire_to_stop = false;\n\n    // var max_index = null;\n\n    // var stop_next_event_loop_iteration = false;\n\n    // ------------ below testing only ------------ //\n\n    web_audio_obj.set_send_audio_to_server(output_stored_media);\n\n    // bbbbbbbbbbb\n\n    // ------------ above testing only ------------ //\n\n\n\treturn {\n\n        set_header_info : function(given_headers_obj) {\n\n            web_audio_obj.manage_media_headers.set_values(given_headers_obj);\n        },\n        set_BUFF_SIZE_AUDIO_RENDERER : function(given_buff_size) {\n\n            web_audio_obj.set_BUFF_SIZE_AUDIO_RENDERER(given_buff_size);\n        },\n\t\tset_queue_min_threshold : function(given_min_threshold) {\n\n\t\t\tweb_audio_obj.queue_first_in_first_out.set_browser_queue_min_threshold(given_min_threshold);\n\t\t},\n\t\tset_queue_max_size : function(given_max_size) {\n\n\t\t\tweb_audio_obj.queue_first_in_first_out.set_browser_queue_max_size(given_max_size);\t\t\t\n\t\t},\n        stop_audio : function(given_msg_to_ww) {\n\n            console.log(\"stop_audio uuuuuuuuuuuuuuuuuu\");\n\n            given_msg_to_ww.browser_directed_mode = \"mode_stop_streaming\";\n\n            // console.log(given_msg_to_ww);\n\n            ww_handle.postMessage(JSON.stringify(given_msg_to_ww));\n\n            if (typeof web_audio_obj !== \"undefined\") {\n\n                web_audio_obj.queue_first_in_first_out.set_request_stop();\n\n                // if (curr_web_audio_obj && (! curr_web_audio_obj.is_streaming_status_ready())) {\n\n                console.log(\"stop_audio\");\n            }\n        },\n        get_is_production_possible : function() {\n\n            return web_audio_obj.queue_first_in_first_out.is_production_possible();\n        },\n        set_is_streaming_done : function(given_max_index) {\n\n            streaming_is_done = true;\n\n            web_audio_obj.queue_first_in_first_out.set_max_index(given_max_index);\n        },\n        get_is_streaming_done : function() {\n\n            return streaming_is_done;\n        },\n        get_flag_audio_rendering : function() {\n\n            return web_audio_obj.queue_first_in_first_out.get_flag_audio_rendering();\n        },\n        launch_audio_streaming_done : function() {\n\n            web_audio_obj.process_audio_buffer();\n        }\n\t};\n}());       //      manage_audio\n\nfunction populate_launch_stream_audio_msg(msgs_to_server) {\n\n    // var request_number = new Date().getTime();\n\n    // ---\n\n    var stop_streaming_msg = {};\n\n    stop_streaming_msg.mode = \"mode_stop_streaming\";\n    stop_streaming_msg.requested_action = \"stop_streaming\";\n    // stop_streaming_msg.request_number = request_number;\n\n    msgs_to_server.mode_stop_streaming = stop_streaming_msg;\n\n    // ---\n\n    var stream_audio_msg = {};\n\n    // stream_audio_msg.mode = 6;\n    stream_audio_msg.mode = \"mode_stream_audio\";\n    stream_audio_msg.requested_action = \"stream_audio_to_client\";\n    // stream_audio_msg.requested_source = media_file;\n    // stream_audio_msg.cb_client_to_server_to_client = callback; // stens TODO bridge\n\n    // stream_audio_msg.request_number = request_number;\n\n    // var transmit_chunk_multiplier = 2; // size of server requests are this multiple of render chunksize\n    // var transmit_chunk_multiplier = 4; // size of server requests are this multiple of render chunksize\n    // var transmit_chunk_multiplier = 8; // size of server requests are this multiple of render chunksize\n    // var transmit_chunk_multiplier = 16; // size of server requests are this multiple of render chunksize\n\n    // stream_audio_msg.limit_buffer_size = 0;\n\n    // ---\n\n    // delay start of audio rendering until we have buffered up a hefty cache of audio\n    // size of circular queue memory buffer is this factor times transmit chunk multiplier times render chunksize\n    // var cushion_factor = 1;\n    // var cushion_factor = 2;\n    // var cushion_factor = 3;\n    // var cushion_factor = 6;\n    // var cushion_factor = 10;\n    var cushion_factor = 15; \n    // var cushion_factor = 20;\n    // var cushion_factor = 30;\n    // var cushion_factor = 50;\n    // var cushion_factor = 100;\n\n    // ---\n\n    var transmit_chunk_multiplier = null;\n    var BUFF_SIZE_AUDIO_RENDERER = null;\n\n    // var array_render_N_chunk = { BUFF_SIZE_AUDIO_RENDERER : 2048, transmit_chunk_multiplier : 16 };\n    // var array_render_N_chunk = { BUFF_SIZE_AUDIO_RENDERER : 4096, transmit_chunk_multiplier : 8 };\n    // var array_render_N_chunk = { BUFF_SIZE_AUDIO_RENDERER : 8192, transmit_chunk_multiplier : 4 };\n    var array_render_N_chunk = { BUFF_SIZE_AUDIO_RENDERER : 16384, transmit_chunk_multiplier : 2 };\n\n    BUFF_SIZE_AUDIO_RENDERER  = array_render_N_chunk.BUFF_SIZE_AUDIO_RENDERER;\n    transmit_chunk_multiplier = array_render_N_chunk.transmit_chunk_multiplier;\n\n    console.log(\"BUFF_SIZE_AUDIO_RENDERER \" + BUFF_SIZE_AUDIO_RENDERER + \n                \"\\ntransmit_chunk_multiplier \" + transmit_chunk_multiplier);\n\n    // var BUFF_SIZE_AUDIO_RENDERER = 2048;\n    // var BUFF_SIZE_AUDIO_RENDERER = 4096;\n    // var BUFF_SIZE_AUDIO_RENDERER = 8192;\n    // var BUFF_SIZE_AUDIO_RENDERER = 16384;\n\nvar browser_queue_max_size      = null; // browser side maximum queue size\nvar browser_queue_min_threshold = null; // triggers browser from consuming its own queue to reading ww queue\n\n    var array_min_thr_N_size = { browser_queue_max_size : 10, browser_queue_min_threshold : 6 };// good one\n    // var array_min_thr_N_size = { browser_queue_max_size : 16, browser_queue_min_threshold : 6 };\n    // var array_min_thr_N_size = { browser_queue_max_size : 18, browser_queue_min_threshold : 6 };// good\n    // var array_min_thr_N_size = { browser_queue_max_size : 24, browser_queue_min_threshold : 6 };\n    // var array_min_thr_N_size = { browser_queue_max_size : 28, browser_queue_min_threshold : 8 };// slow start\n\n    browser_queue_max_size       = array_min_thr_N_size.browser_queue_max_size;\n    browser_queue_min_threshold  = array_min_thr_N_size.browser_queue_min_threshold;\n\n    stream_audio_msg.transmit_chunksize = BUFF_SIZE_AUDIO_RENDERER * transmit_chunk_multiplier;\n\n    stream_audio_msg.BUFF_SIZE_AUDIO_RENDERER = BUFF_SIZE_AUDIO_RENDERER;\n\n\n    stream_audio_msg.browser_queue_min_threshold = browser_queue_min_threshold;\n    stream_audio_msg.browser_queue_max_size = browser_queue_max_size;\n    // stream_audio_msg.ww_queue_max_size = browser_queue_max_size * 2; // integer multiple >= 2\n    stream_audio_msg.ww_queue_max_size = browser_queue_max_size * 4; // integer multiple >= 2\n    // stream_audio_msg.ww_queue_max_size = browser_queue_max_size * 6; // integer multiple >= 2 # good one\n    // stream_audio_msg.ww_queue_max_size = browser_queue_max_size * 8; // integer multiple >= 2\n\n    msgs_to_server.mode_stream_audio_to_client = stream_audio_msg;\n\n}\t//\tpopulate_launch_stream_audio_msg\n\nfunction process_file_headers(received_json) {\n\n    manage_audio.set_header_info(received_json);\n}\n\nfunction process_ww_directed_mode(received_json) {\n\n    // console.log(\"process_ww_directed_mode\");\n    // console.log(received_json);\n\n    var ww_directed_mode = received_json.ww_directed_mode;\n\n    // console.log(ww_directed_mode);\n\n    switch (ww_directed_mode) {\n\n        case \"streaming_is_done\" : {\n\n            console.log(\"cool seeing streaming_is_done\");\n\n            var max_index = received_json.max_index;\n\n            if (typeof max_index !== \"undefined\") {\n\n                manage_audio.set_is_streaming_done(max_index);\n\n                if (! manage_audio.get_flag_audio_rendering()) {\n\n                    console.log(\"flag    manage_audio.get_flag_audio_rendering \" +\n                                manage_audio.get_flag_audio_rendering());\n\n                    console.log(\"launch_audio_streaming_done    ===========\");\n\n                    manage_audio.launch_audio_streaming_done();\n                }\n\n            } else {\n\n                throw new Error(\"ERROR - seeing streaming_is_done yet not seeing max_index\");\n            }\n\n            break;\n        }\n\n        default : {\n\n            throw new Error(\"ERROR - invalid ww_directed_mode\");\n        }\n    }\n}\n\n\nvar send_audio_to_server = (function() {\n\n    var array_this_media = [];\n\n    return {\n\n        store_this_buffer : function (retrieved_audio_buffer_obj) {\n\n            array_this_media.push(retrieved_audio_buffer_obj);\n        },\n        output_media : function() {\n\n            // return;\n\n\n            // return array_this_media;\n\n            var saveByteArray = (function () {\n\n                var a = document.createElement(\"a\");\n                document.body.appendChild(a);\n                a.style = \"display: none\";\n\n                return function (data, name) {\n                    \n                    var blob = new Blob(data, {type: \"octet/stream\"}),\n                        url = window.URL.createObjectURL(blob);\n                    a.href = url;\n                    a.download = name;\n                    a.click();\n                    window.URL.revokeObjectURL(url);\n                };\n            }());\n\n\n            // return;\n\n\n            console.log(\"aaaaaaaaaaaaaaaaaa cb_send_audio_to_server\");\n\n            console.log(\"array_retrieved_media_buffers length \" + array_this_media.length);\n\n            // bbbbbbbbbbbb\n\n            for (var curr_element in array_this_media) {\n\n                var curr_buffer = array_this_media[curr_element];\n\n                console.log(curr_element + \" length \" + curr_buffer.buffer.length);\n            }\n\n            // ---\n\n\n// var sampleBytes = base64ToArrayBuffer('R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs');\n// saveByteArray([sampleBytes], 'black1x1.gif');\n\n\n        }\n    };\n}());\n\nww_handle.onmessage = function(event) {  // handle traffic from ww\n\n    if (event.data instanceof ArrayBuffer) {\n\n        var elapsed = common_utils.seconds(startTime);\n\n        var data_from_ww = event.data;\n\n        var stats_this_launch = {};\n\n        // log('postMessage roundtrip took: ' + (elapsed * 1000) + ' ms');\n\n        stats_this_launch.elapsed = common_utils.seconds(startTime);\n\n        var rate_KB = Math.round(common_utils.toKB(data_from_ww.byteLength) / elapsed);\n        // log('postMessage roundtrip rate: ' + rate_KB + ' KB/s');\n\n        stats_this_launch.rate_KB = rate_KB;\n\n        array_stats_for_launch.push(stats_this_launch);\n\n        var retrieved_audio_buffer_obj = {};\n\n        retrieved_audio_buffer_obj.buffer = new Float32Array(data_from_ww);\n\n        callback_send_audio_to_audio_player(retrieved_audio_buffer_obj, manage_state.is_early_days());\n\n        // ---------  following testing only --------- //\n\n        // now send this array buffer back to server side\n\n        send_audio_to_server.store_this_buffer(retrieved_audio_buffer_obj);\n\n        // bbbbbbbbbbbbbbb\n\n    } else if (typeof event.data === \"string\") {\n\n        var received_json = JSON.parse(event.data);\n\n        if (typeof received_json.ww_directed_mode !== \"undefined\") {\n\n            process_ww_directed_mode(received_json);\n\n        } else if (typeof received_json.sample_rate !== \"undefined\") { \n\n            process_file_headers(received_json);\n\n        } else {\n\n            // throw new Error(\"ERROR - ww is not sending JSON with key ww_directed_mode\");\n            console.log(\"ERROR - ww is not sending JSON with key ww_directed_mode\");\n        }\n\n    } else if (event.data instanceof Blob) {\n\n        console.log(\"Received Blob from ww\");\n\n    } else if (event.data.type && event.data.type == 'debug') {\n\n        // log(event.data.msg);\n        console.log(event.data.script_name + \" \" + event.data.msg);\n\n        // console.log(\"Received msg with debug from ww\", event.data);\n\n    } else {\n\n        console.log(\"ERROR - received unknown from ww - here is event.data \");\n        // console.log(event.data);\n\n\n        shared_utils.show_object(event.data, \"event.data\", \"total\", 10);\n\n\n    }\n};\n\nvar media_manager = (function() {\n\n    var all_media = {}; // stens TODO - populate from server supplied list\n\n//       ls -Slr media/  | cut -c25-34,48-999\n\n    // all_media[0] = \"Justice_Genesis_first_third_sec_tight.wav\"; // its 8 bit not 16 bit like all others here\n    // all_media[1] = \"sine_wave_32768_64.wav\";\n    all_media[2] = \"sine_wave_32768_128.wav\";\n    // all_media[3] = \"sine_wave_32768_64.wav\";\n    // all_media[4] = \"sine_wave_65536_64.wav\";\n    all_media[5] = \"Lee_Smolin_Physics_Envy_and_Economic_Theory-cWn86ESze6M_mono_1st_few_seconds_trim.wav\";\n    // all_media[6] = \"1_to_11.wav\";\n    // all_media[7] = \"Viola_16_Jay_Haide_a_L_Ancienne_Stradivari-H4ri4jE14cE_4_seconds.wav\";\n    // all_media[8] = \"sine_wave_262144_64.wav\";\n    // all_media[9] = \"Viola_16_Jay_Haide_a_L_Ancienne_Stradivari-H4ri4jE14cE_10_seconds.wav\";\n    // all_media[10] = \"Elephant_sounds_mono_cute_clip_rgUFu_hVhlk.wav\";\n    // all_media[11] = \"Elephant_sounds_mono_clip_rgUFu_hVhlk.wav\";\n    // all_media[12] = \"Die_Antwoord_11_doong_doong_30_sec.wav\";\n    all_media[13] = \"SHAKUHACHI_Masayuki_Koga_trim_mono-IMi00aV1tdA.wav\";\n    // all_media[14] = \"Glenn_Gould_Partita_No_5_BWV_829_Praeambulum_mono-0YvnW_lMNTM.wav\";\n    // all_media[15] = \"Contrabass_Saxophone_mono_hXBeu7o9uUM.wav\";\n    all_media[16] = \"Justice_Genesis_first_30_seconds_tight.wav\";\n    all_media[17] = \"Justice_Genesis_chewy_chocolate_cookies_gtZunGHG0ls_mono.wav\";\n    // all_media[17] = \"Chopin_Fantasie_Impromptu_opus_66_mono_clip_APQ2RKECMW8.wav\";\n    all_media[18] = \"binaural_clapping_stereo_2_ch.wav\";\n\n    return {\n\n        get_media_filename : function(chosen_media) {\n\n            var chosen_media_filename = all_media[chosen_media];\n\n            if (typeof chosen_media_filename === \"undefined\") {\n\n                throw new Error(\"ERROR - failed to resolve media filename for chosen_media : \" + chosen_media);\n            }\n\n            return chosen_media_filename;\n        }\n    };\n}());\n\n\n// var ignore_console = (function() {\nvar console = (function() {\n\n// var scripts = document.getElementsByTagName('script');\n// var lastScript = scripts[scripts.length-1];\n// var scriptName = lastScript.src;\n\n    // shared_utils.show_object(scripts, \"scripts\", \"total\", 10);\n\n    function getScriptName() {\n\n        var error = new Error();\n        var source = null;\n        var lastStackFrameRegex = new RegExp(/.+\\/(.*?):\\d+(:\\d+)*$/);\n        var currentStackFrameRegex = new RegExp(/getScriptName \\(.+\\/(.*):\\d+:\\d+\\)/);\n\n        // if((source = lastStackFrameRegex.exec(error.stack.trim())) && source[1] != \"\")\n        if((source = lastStackFrameRegex.exec(error.stack.trim())) && source[1] !== \"\")\n            return source[1];\n        else if((source = currentStackFrameRegex.exec(error.stack.trim())))\n            return source[1];\n        else if(error.fileName !== undefined)\n            return error.fileName;\n    }\n\n    return {\n\n        log : function(given_str) {\n\n            if (typeof given_str === \"string\" && given_str.indexOf(\"worker_log\") > -1) {\n\n                common_utils.log(given_str);\n\n            } else {\n\n                common_utils.log(getScriptName() + \" \" + common_utils.source() + given_str);\n            }\n        }\n    };\n}());\n\n\n// var log = function(given_str) {\n\n//     common_utils.log(common_utils.source() + given_str);\n// };\n\n\n\nvar entry_point = (function() {     //      handle traffic from browser UI\n\n    // log(\"entry_point\");\n    console.log(\"entry_point\");\n\n    var msg_to_ww = {};\n\n    populate_launch_stream_audio_msg(msg_to_ww);\n\n    var mode_stream_audio_to_client = msg_to_ww.mode_stream_audio_to_client;\n    var mode_stop_streaming         = msg_to_ww.mode_stop_streaming;\n\n    // shared_utils.show_object(msg_to_ww, \"msg_to_ww\", \"total\", 10);\n\n    // shared_utils.show_object(mode_stream_audio_to_client, \"mode_stream_audio_to_client\", \"total\", 10);\n\n    console.log(\"\\n\\nmsg_to_ww\\n\\n\");\n    console.log(msg_to_ww);\n    console.log(\"\\n\\n\");\n\n    msg_to_ww.browser_directed_mode = \"setup_stream_audio_from_server\";\n\n    // shared_utils.show_object(msg_to_ww, \"msg_to_ww SEETTUUPP\", \"total\", 10);\n\n    manage_audio.set_BUFF_SIZE_AUDIO_RENDERER(msg_to_ww.mode_stream_audio_to_client.BUFF_SIZE_AUDIO_RENDERER);\n    manage_audio.set_queue_min_threshold(msg_to_ww.mode_stream_audio_to_client.browser_queue_min_threshold);\n    manage_audio.set_queue_max_size(msg_to_ww.mode_stream_audio_to_client.browser_queue_max_size);\n\n    /*\n    msg_to_ww.browser_directed_mode = manage_state.get_state();\n\n    msg_to_ww.mode = msg_to_ww.mode_stream_audio_to_client.mode;\n    msg_to_ww.requested_action = msg_to_ww.mode_stream_audio_to_client.requested_action;\n    msg_to_ww.requested_source = media_file;\n    */\n\n    ww_handle.postMessage(JSON.stringify(msg_to_ww));\n\n    // --------\n\n    var curr_msg_stream = {};\n    var curr_msg_stop = null;\n    var curr_request_number = null;\n\n\treturn function(request, chosen_media) {\n\n\t\tswitch (request) {\n\n            case \"launch_stream_audio\" : {\n\n                // ---\n\n                if (typeof chosen_media !== \"undefined\") {\n\n                } else {\n\n                    throw new Error(\"ERROR - browser must supply chosen_media\");\n                }\n\n                var media_file = media_manager.get_media_filename(chosen_media);\n\n                console.log(\"media_file \" + media_file);\n\n                // manage_audio.stop_audio(msg_to_ww);\n\n                // --------- deal with stopping prior run --------- //\n\n                if (curr_msg_stop) {\n\n                    console.log(\"deal with prior run .... curr_msg_stop\");\n                }\n\n                // ------ stens TODO identify if we need to issue a stop_audio on current request_number\n\n                curr_request_number = new Date().getTime();\n\n                curr_msg_stop = mode_stop_streaming;\n                curr_msg_stop.request_number = curr_request_number;\n                curr_msg_stop.requested_source = media_file;\n\n                // ---\n\n                curr_msg_stream = mode_stream_audio_to_client;\n                curr_msg_stream.request_number = curr_request_number;\n                curr_msg_stream.browser_directed_mode = manage_state.get_state();\n                curr_msg_stream.requested_source = media_file;\n\n                console.log(\"just POPulated requested_source\");\n\n\n                console.log(\"\\n\\n launch_stream_audio \\n\\n\");\n                console.log(curr_msg_stream);\n                console.log(\"\\n\\n\");\n                console.log(\"curr_msg_stream.browser_directed_mode \" + curr_msg_stream.browser_directed_mode);\n                console.log(\"                     media_file \" + media_file);\n                console.log(\"\\n\\n\");\n\n                startTime = new Date();\n\n                manage_state.set_msg_to_server_by_mode(manage_state.get_state(), curr_msg_stream);\n\n                var returned_msg = manage_state.get_msg_to_server_by_mode(manage_state.get_state());\n\n                // shared_utils.show_object(returned_msg, \"returned_msg uuu uuu uuu uuu uuu\", \"total\", 10);\n\n                // shared_utils.show_object(curr_msg_stream, \"curr_msg_stream MMMMMMMMMMMMMMMMM\", \"total\", 10);\n\n                ww_handle.postMessage(JSON.stringify(curr_msg_stream));\n\n                break;\n            }\n\n            case \"stop_audio\" : {\n\n                shared_utils.show_object(curr_msg_stop, \"curr_msg_stop pp pp pp pp pp p\", \"total\", 10);\n\n                manage_audio.stop_audio(curr_msg_stop);\n\n                break;\n            }\n\n\t\t\tdefault : {\n\n\t\t\t\tthrow new Error(\"ERROR - invalid request sent to entry_point : \", request);\n\t\t\t}\n\t\t}\n\t};\n\n}());\n\nreturn {\n\n\tentry_point : entry_point\n};\n\n}());\t//\tclient_entry","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/src/common_utils.js":"\nvar common_utils = (function() {\n\n// ---------------------------\n\nfunction setClone( ab ) {\n\n      var f32 = new Float32Array(ab.length);\n      f32.set(ab);\n      return f32;\n    }\n\n// http://www.html5rocks.com/en/tutorials/webgl/typed_arrays/\n// function memcpy(dst, dstOffset, src, srcOffset, length) {\n//   var dstU8 = new Uint8Array(dst, dstOffset, length);\n//   var srcU8 = new Uint8Array(src, srcOffset, length);\n//   dstU8.set(srcU8);\n// };\n\n\nfunction memcpy_float_32_bit(dst, dstOffset, src, srcOffset, length) {\n\n  var destination_float = new Float32Array(dst, dstOffset, length);\n  var source_float      = new Float32Array(src, srcOffset, length);\n  destination_float.set(source_float);\n\n  return destination_float;\n};\n\n\n\n\n\nfunction time() {\n  var now = new Date();\n  var time = /(\\d+:\\d+:\\d+)/.exec(now)[0] + ':';\n  for (var ms = String(now.getMilliseconds()), i = ms.length - 3; i < 0; ++i) {\n    time += '0';\n  }\n  return time + ms;\n}\n\nfunction source(s) {\n  if (self.importScripts) {\n    return '<span style=\"color:red;\">worker_log:</span> ';\n  } else {\n    return '<span style=\"color:green;\">thread:</span> ';\n  }\n}\n\nfunction seconds(since) {\n  return (new Date() - since) / 1000.0;\n}\n\nfunction toMB(bytes) {\n  return Math.round(bytes / 1024 / 1024);\n}\n\n\nfunction toKB(bytes) {\n  return Math.round(bytes / 1024);\n}\n\n// ---------------------------\n\n\nfunction log(str) {\n  var elem = document.getElementById('result');\n  var log = function(s) {\n   elem.innerHTML += ''.concat(time(), ' ', s, '\\n');\n  };\n  log(str);\n}\n\n// --------------------\n\nreturn {\n\n\tlog : log,\n\tsource : source,\n\ttime : time,\n\tseconds : seconds,\n\ttoMB : toMB,\n\ttoKB : toKB,\n\tmemcpy_float_32_bit : memcpy_float_32_bit\n\n}\n\n}());","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/src/render_streaming_web_audio.js":"\nvar render_streaming_web_audio = function() {\n\nvar audio_context;\nvar gain_node;\nvar streaming_node;\nvar BUFF_SIZE_AUDIO_RENDERER = null;\nvar cb_request_another_buffer = null;\nvar cb_send_audio_to_server = null;\n\nvar streaming_status_ready      = \"streaming_status_ready\";\nvar streaming_status_active     = \"streaming_status_active\";\nvar streaming_status_done       = \"streaming_status_done\";\nvar flag_streaming_status       = streaming_status_ready;\n\n\n// var ignore_console = (function() {\nvar console = (function() {\n\n    // shared_utils.show_object(scripts, \"scripts\", \"total\", 10);\n\n    function getScriptName() {\n\n        var error = new Error();\n        var source = null;\n        var lastStackFrameRegex = new RegExp(/.+\\/(.*?):\\d+(:\\d+)*$/);\n        var currentStackFrameRegex = new RegExp(/getScriptName \\(.+\\/(.*):\\d+:\\d+\\)/);\n\n        // if((source = lastStackFrameRegex.exec(error.stack.trim())) && source[1] != \"\")\n        if((source = lastStackFrameRegex.exec(error.stack.trim())) && source[1] !== \"\")\n            return source[1];\n        else if((source = currentStackFrameRegex.exec(error.stack.trim())))\n            return source[1];\n        else if(error.fileName !== undefined)\n            return error.fileName;\n    }\n\n\n    return {\n\n        log : function(given_str) {\n\n            // common_utils.log(document.currentScript, scriptName + \" \" + common_utils.source() + given_str);\n            // common_utils.log(document.currentScript.toString() + \" \" + common_utils.source() + given_str);\n            common_utils.log(getScriptName() + \" \" + common_utils.source() + given_str);\n        }\n    };\n}());\n\n\n\n\nvar init_web_audio = (function() {\n\n\tif (typeof audio_context !== \"undefined\") {\n\n        return;     //      audio_context already defined\n    }\n\n    try {\n\n        window.AudioContext = window.AudioContext       ||\n                              window.webkitAudioContext ||\n                              window.mozAudioContext    ||\n                              window.oAudioContext      ||\n                              window.msAudioContext;\n\n        audio_context = new AudioContext();  //  cool audio context established\n\n    } catch (e) {\n\n        var error_msg = \"Web Audio API is not supported by this browser\\n\" +\n                        \" ... http://caniuse.com/#feat=audio-api\";\n        console.error(error_msg);\n        alert(error_msg);\n        throw new Error(error_msg);\n    }\n\n    gain_node = audio_context.createGain(); // Declare gain node\n    gain_node.connect(audio_context.destination); // Connect gain node to speakers\n\n}());\n\nfunction setup_onaudioprocess_callback_stream(given_node, cb_populate_memory_chunk, given_buff_size, given_num_channels) {\n\n    console.log(\"TOP setup_onaudioprocess_callback_stream\");\n\n    var internal_audio_buffer_obj = {};\n    var buff_size_audio_renderer = given_buff_size;\n    var aggregate_buffer_index = 0;\n    var stop_next_event_loop_iteration = false;\n\n    given_node.onaudioprocess = (function() {\n\n        return function(event) {\n\n            // console.log(\"Middleburg  top of rendering callback ----------------------------------\");\n\n            queue_first_in_first_out.set_flag_audio_rendering(true);\n\n            if (stop_next_event_loop_iteration || queue_first_in_first_out.get_request_stop()) {\n\n                console.log(\"stop event loop\");\n\n                stop_audio();\n                \n                return;\n            }\n\n            aggregate_buffer_index += buff_size_audio_renderer;\n\n            var max_index = queue_first_in_first_out.get_max_index();\n\n            // console.log(\"aggregate_buffer_index \" + aggregate_buffer_index);\n            // console.log(\"             max_index \" + max_index);\n\n            if (max_index && (aggregate_buffer_index > max_index)) {\n\n                console.log(\"reached end of audio streaming\");\n\n                stop_next_event_loop_iteration = true;\n            }\n\n            for (var curr_channel = 0; curr_channel < given_num_channels; curr_channel++) {\n\n                internal_audio_buffer_obj[curr_channel] = event.outputBuffer.getChannelData(curr_channel);\n            }\n\n            // retrieve buffer data from queue\n            cb_populate_memory_chunk(internal_audio_buffer_obj, given_num_channels);\n\n            cb_request_another_buffer(\"Middleburg\");\n        };\n    }());\n}           //      setup_onaudioprocess_callback_stream\n\n// ---\n\nvar manage_media_headers = (function() {\n\n    var headers_obj = null;\n\n// shared_utils.js:328 process_file_headers  property -->audio_format<--    1\n// shared_utils.js:328 process_file_headers  property -->num_channels<--    1\n// shared_utils.js:328 process_file_headers  property -->sample_rate<--     44100\n// shared_utils.js:328 process_file_headers  property -->byte_rate<--   88200\n// shared_utils.js:328 process_file_headers  property -->bit_depth<--   16\n// shared_utils.js:328 process_file_headers  property -->block_align<--     2\n// shared_utils.js:328 process_file_headers  property -->bits_per_sample<--     16\n\n    return {\n\n        set_values : function (received_headers_info_json) {\n\n            headers_obj = received_headers_info_json;\n\n            // shared_utils.show_object(headers_obj, \"headers_obj heheheheh\", \"total\", 10);\n        },\n\n        get_value : function(given_property) {\n\n            // console.log(\"about to get value given_property \" + given_property);\n\n            if (headers_obj && typeof headers_obj[given_property] !== \"undefined\") {\n\n                return headers_obj[given_property];\n\n            } else {\n\n                throw new Error(\"ERROR - failed to find headers property : \" + given_property);\n            }\n        }\n    };\n}());\n\n// ---\n\nvar queue_first_in_first_out = (function() { // first in first out queue\n\n    var audio_from_server_obj = {};\n    var push_index = 0;\n    var pop_index = 0;\n    var browser_queue_max_size = 4;   //  maximum queue size\n    var browser_queue_min_threshold = 2; //  triggers browser from consuming its own queue to reading ww queue\n    var cb_browser_queue_is_full = null;\n    var cb_browser_queue_min_reached = null;\n    var curr_browser_queue_size = 0;\n    // var cb_get_state = null;\n    var max_index = null;\n\n    // ~/Dropbox/Documents/code/github/websockets-streaming-audio/src_ce/thermostat.js\n\n    var flag_index_is_rising = true; // trigger used to identify when traversing min threshold\n    var flag_request_stop = false; // trigger to stop web audio api event loop\n\n    var flag_audio_rendering = false;\n\n    return {\n        is_production_possible : function() {\n\n            var curr_size_queue = push_index - pop_index;\n\n            var answer = ((push_index - pop_index) < browser_queue_max_size);\n\n            // console.log(\"is_BB_production_possible  answer \" + answer);\n\n            if (flag_index_is_rising && curr_size_queue >= browser_queue_max_size) {\n\n                flag_index_is_rising = false; // thermostat threshold triggered - browser queue full\n\n                cb_browser_queue_is_full(); // communicate this state change to state management\n\n                // console.log(\"NEW browser_directed_mode\");\n            }\n\n            return answer;\n        },\n        push : function(given_audio_obj_from_server) {      // bbb\n\n            var size_buffer_available = given_audio_obj_from_server.buffer.length;\n\n            var offset_index = 0;\n            while (size_buffer_available > offset_index) { // carve out render sized buffers from given buffer\n\n                // stens TODO - put this into ww not here in browser land\n\n                var array_buffer = new ArrayBuffer(BUFF_SIZE_AUDIO_RENDERER * Float32Array.BYTES_PER_ELEMENT);\n                var float_array = new Float32Array(array_buffer);\n\n                for (var i = 0; i < BUFF_SIZE_AUDIO_RENDERER; i++) {\n\n                    float_array.buffer[i] = given_audio_obj_from_server.buffer[i + offset_index];\n                }\n\n                // console.log(\"ccccccccccccccc float_array \" + float_array.buffer[0]);\n\n                audio_from_server_obj[push_index] = float_array;\n\n                // console.log(\"post push value \" + audio_from_server_obj[push_index].buffer[0]);\n\n                push_index += 1;\n\n                offset_index += BUFF_SIZE_AUDIO_RENDERER;\n\n                curr_browser_queue_size += 1;\n\n                // console.log(\"PUSH curr_browser_queue_size \" + curr_browser_queue_size);\n            }\n        },\n        is_pop_possible : function() {\n\n            var curr_size_queue = push_index - pop_index;\n\n            if ((! flag_index_is_rising) && curr_size_queue <= browser_queue_min_threshold) {\n\n                flag_index_is_rising = true; // thermostat threshold triggered - browser queue about empty\n\n                cb_browser_queue_min_reached();\n            }\n\n            return (pop_index < push_index && flag_streaming_status !== streaming_status_done);\n        },\n        pop : function() {\n\n            if (pop_index > 0) {\n\n                delete audio_from_server_obj[pop_index - 1]; // destroy previously consumed entry\n            }\n\n            if (pop_index < push_index) {\n\n                curr_browser_queue_size -= 1;\n\n                // bbbb useful logging\n                // console.log(\"             browser queue \" + curr_browser_queue_size);\n\n                return audio_from_server_obj[pop_index++];\n\n            } else {\n\n                throw new Error(\"ERROR - boo hoo queue_first_in_first_out is EMPTY so cannot do a pop\");\n            }\n        },\n        set_browser_queue_min_threshold : function(given_minimum_threshold) {\n\n            browser_queue_min_threshold = given_minimum_threshold;\n        },\n        set_browser_queue_max_size : function(given_maximum_queue_size) {\n\n            browser_queue_max_size = given_maximum_queue_size;\n        },\n        set_cb_browser_queue_is_full : function(given_callback) {\n\n            cb_browser_queue_is_full = given_callback;\n        },\n        set_cb_browser_queue_min_reached : function(given_callback) {\n\n            cb_browser_queue_min_reached = given_callback;\n        },\n        set_max_index : function(given_max_index) {\n\n            max_index = given_max_index;\n        },\n        get_max_index : function() {\n\n            return max_index;\n        },\n        set_request_stop : function() {\n\n            flag_request_stop = true;\n\n            console.log(\"set_request_stop  flag_request_stop \" + flag_request_stop);\n        },\n        get_request_stop : function() {\n\n            return flag_request_stop; // retrieve flag to indicate whether to exit from web audio event loop\n        },\n        set_flag_audio_rendering : function() {\n\n            flag_audio_rendering = true;\n        },\n        get_flag_audio_rendering : function() {\n\n            return flag_audio_rendering;\n        }\n    };\n}());       //      queue_first_in_first_out\n\nvar set_BUFF_SIZE_AUDIO_RENDERER = function(given_buff_size) {\n\n    BUFF_SIZE_AUDIO_RENDERER = given_buff_size;\n};\n\nvar get_another_buffer = (function () {\n\n    return (function(given_audio_obj, num_channels) {\n\n        // pull out all buffers .. see buffer_left  buffer_right\n\n        // for (var curr_property in given_audio_obj) {\n\n        //     if (given_audio_obj.hasOwnProperty(curr_property)) {\n\n        //         console.log(\"current buffer number : \" + curr_property);\n        //     }\n        // }\n\n        // stens TODO - believe we want to put a loop here - num_channels\n\n        // for (var curr_outer_channel = 0; curr_outer_channel < num_channels; curr_outer_channel++) {\n\n            if (queue_first_in_first_out.is_pop_possible()) {\n\n                var audio_obj_from_queue = queue_first_in_first_out.pop();\n\n                if (typeof audio_obj_from_queue === \"undefined\") {\n\n                    throw new Error(\"ERROR - in get_another_buffer seeing undefined audio_obj_from_queue\");\n                }\n\n                var size_buff = audio_obj_from_queue.length;\n                var curr_channel = 0;\n\n                for (var i = 0; i < size_buff; i++) {\n\n                    // given_audio_obj.buffer[i] = audio_obj_from_queue.buffer[i]; // pre multi channel\n\n                    given_audio_obj[curr_channel][i] = audio_obj_from_queue.buffer[i];\n\n                    // if (i < 1) {\n\n                    //     console.log(\"FROM  \" + audio_obj_from_queue.buffer[i] + \n                    //                 \"  TO  \" + given_audio_obj[curr_channel][i]);\n                    // }\n\n                    curr_channel += 1;\n\n                    if (curr_channel === num_channels) {\n\n                        curr_channel = 0;\n                    }\n                }\n            }\n        // }\n    });\n}());\n\nvar set_cb_request_another_buffer = function(given_callback) {\n\n    cb_request_another_buffer = given_callback;\n};\n\nfunction set_send_audio_to_server(send_audio_to_server) {\n\n    cb_send_audio_to_server = send_audio_to_server;\n}\n\nfunction output_stored_media_as_downloaded_file () {\n\n    cb_send_audio_to_server();\n}\n\n\nfunction stop_audio() {\n\n    // queue_first_in_first_out.set_stop();\n\n    streaming_node.disconnect(gain_node); // stens TODO why is this not enough to stop event loop\n\n    streaming_node.onaudioprocess = null;\n\n    streaming_node = null;\n\n    console.log('stop_audio ... just called disconnect');\n    console.log('stop_audio ... just called disconnect');\n    console.log('stop_audio ... just called disconnect');\n\n    flag_streaming_status = streaming_status_ready; // get ready for next time\n\n    console.log(\"OK just set flag_streaming_status = streaming_status_ready\");\n\n    // ----------------  testing only ---------------- //\n\n    output_stored_media_as_downloaded_file();\n}\n\nfunction process_audio_buffer() { // only called upon initially retrieving audio fm svr\n\n    if (! queue_first_in_first_out.get_flag_audio_rendering() && (\n        (! queue_first_in_first_out.is_production_possible())) ||\n        cb_get_is_streaming_done()) {\n\n        queue_first_in_first_out.set_flag_audio_rendering(true);\n\n        var num_channels = manage_media_headers.get_value(\"num_channels\");\n\n        // streaming_node = audio_context.createScriptProcessor(BUFF_SIZE_AUDIO_RENDERER, 1, 1);\n        streaming_node = audio_context.createScriptProcessor(BUFF_SIZE_AUDIO_RENDERER, num_channels, num_channels);\n\n        console.log(\"BUFF_SIZE_AUDIO_RENDERER \", BUFF_SIZE_AUDIO_RENDERER);\n\n        console.log(\"OOOOOOOOOOOOOOOONNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN activating gain_node\");\n\n        streaming_node.connect(gain_node);\n\n        flag_streaming_status = streaming_status_active;\n\n        console.log(\"OK just set flag_streaming_status    streaming_status_active\");\n\n        setup_onaudioprocess_callback_stream(streaming_node, get_another_buffer, BUFF_SIZE_AUDIO_RENDERER, num_channels);\n\n    } else {\n\n        // console.log(\"jjjjjjjjjjjjjj  early_days\");\n\n        cb_request_another_buffer(\"early_days\");\n    }\n}\n\nfunction set_cb_is_streaming_done(given_callback) {\n\n    cb_get_is_streaming_done = given_callback;\n}\n\nfunction cb_send_buffer_to_web_audio_player(given_audio_obj, flag_early_or_not) {\n\n    queue_first_in_first_out.push(given_audio_obj);\n\n    if (flag_early_or_not) {\n\n        process_audio_buffer(); // safe to do this since not competing with rendering processing   \n    }\n}\n\nreturn {\n\n    cb_send_buffer_to_web_audio_player : cb_send_buffer_to_web_audio_player,\n    queue_first_in_first_out : queue_first_in_first_out,\n    set_BUFF_SIZE_AUDIO_RENDERER : set_BUFF_SIZE_AUDIO_RENDERER,\n    set_cb_request_another_buffer : set_cb_request_another_buffer,\n    set_cb_is_streaming_done : set_cb_is_streaming_done,\n    set_send_audio_to_server : set_send_audio_to_server,\n    process_audio_buffer : process_audio_buffer,\n    manage_media_headers : manage_media_headers\n};\n\n};       //      render_streaming_web_audio\n","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/src/shared_utils.js":"\nvar shared_utils = (function() {\n\n\tvar local_random = Math.random;\n\n\tvar set_random_seed = function(given_seed) {\n\n\t\t/*\n\t\t\tIf your process needs a repeatable sequence of random values, then execute\n\t\t\tthis ONCE at top of your process.  Subsequent calls to below get_random_* functions\n\t\t\twill then return the same sequence of random values across process executional runs.\n\t\t\tIMPORTANT - if instead, you need a fresh random sequence across runs then avoid calling this.\n\n\t\t*/\n\n\t\tMath.seed = function(s) {\n\t\t    return function() {\n\t\t        s = Math.sin(s) * 10000; return s - Math.floor(s);\n\t\t    };\n\t\t};\n\n\t\t// usage:\n\t\tvar random1 = Math.seed(given_seed);\n\t\tvar random2 = Math.seed(random1());\n\t\t// Math.random = Math.seed(random2());\n\t\tlocal_random = Math.seed(random2());\n\t};\n\n\t// ---\n\n\t/**\n\t * Returns a random number between min and max inclusive   \n\t */\n\tvar get_random_in_range_inclusive_float = function (min, max) {\n\t    // return Math.random() * (max - min) + min;\n\t    return local_random() * (max - min) + min;\n\t};\n\n\t/**\n\t * Returns a random integer between min and max inclusive \n\t * Using Math.round() will give you a non-uniform distribution!\n\t */\n\tvar get_random_in_range_inclusive_int = function (min, max) {\n\t    // return Math.floor(Math.random() * (max - min + 1)) + min;\n\t    return Math.floor(local_random() * (max - min + 1)) + min;\n\t};\n\n\t// ---\n\n\tvar release_all_prop_from_object = function (given_object) {    // purge memory for object reuse\n\n\t\tfor (var curr_property in given_object)\n\t\t{\n\t\t\tif (given_object.hasOwnProperty(curr_property))\n\t\t\t\tdelete given_object[curr_property];\n\t\t}\n\t};\n\n\tvar convert_32_bit_float_into_unsigned_16_bit_int_lossy = function(input_32_bit_buffer) {\n\n\t\t// this method is LOSSY - intended as preliminary step when saving audio into WAV format files\n\n\t    var size_source_buffer = input_32_bit_buffer.length;\n\n\t    var new_16_bit_array = new Uint16Array(size_source_buffer);\n\n\t    var max_valid_16_bit_integer = -1 + Math.pow(2, 16);\n\n\t    // console.log(\"max_valid_16_bit_integer \", max_valid_16_bit_integer);\n\n\t    // ---\n\n\t    var prelim_value;\n\n\t    for (var index = 0; index < size_source_buffer; index++) {\n\n\t        prelim_value = ~~((input_32_bit_buffer[index] + 1.0) * 32768);\n\t        new_16_bit_array[index] = prelim_value;\n\n\t        if (prelim_value !== new_16_bit_array[index]) {\n\n\t        \tif (prelim_value > max_valid_16_bit_integer) {\n\n\t        \t\tnew_16_bit_array[index] = max_valid_16_bit_integer;\n\n\t        \t} else if (prelim_value < 0) {\n\n\t        \t\tnew_16_bit_array[index] = 0;\n\t        \t}\n\t        }\n\t    }\n\n\t    return new_16_bit_array;\n\t};\n\n\t// ---\n\n\tvar convert_16_bit_unsigned_int_to_32_bit_float = function(input_16_bit_int_buffer) {\n\n\t\t// assumes input range of 16 bit ints :  0 to (2^16 - 1)  == 0 to 65535\n\n\t\tvar size_source_buffer = input_16_bit_int_buffer.length;\n\n\t\tvar max_valid_input_value = 2 >> 16 - 1;\n\n\t\t// console.log(\"max_valid_input_value \", max_valid_input_value);\n\n\n\t\tvar new_32_bit_array = new Float32Array(input_16_bit_int_buffer.length);\n\n\t\tfor (var index = 0; index < size_source_buffer; index++) {\n\n\t\t    new_32_bit_array[index] = input_16_bit_int_buffer[index] / 32768 - 1.0;\n\t\t}\n\n\t\treturn new_32_bit_array;\n\t};\n\n\t// ----------------------\n\n\tvar conv_bit_size = function(input_unsigned_int, bits_per_sample) { // converts unsigned into signed\n\n\t\tvar max = (1 << (bits_per_sample - 1)) - 1;\n\n\t\treturn ((input_unsigned_int > max) ? input_unsigned_int - ((max << 1) + 2) : input_unsigned_int);\n\t};\n\n\tvar convert_16_bit_signed_int_to_32_bit_float = function(input_8_bit_int_buffer) {\n\n\t\t// input buffer is 8 bit integers which need to get shifted and OR'd into 16 bit signed integers\n\t\t//              which is then converted into 32 bit floats\n\t\t//\n\t\t// This does NOT fully utilize 32 bits since input is only 16 bit\n\n\t\t// assumes input range of 16 bit signed ints :  -2^15 to (2^15 - 1)  == -32768 to 32767\n\t\t// ONLY after the shift and logical OR happens from a pair of 8 bit integers\n\n\t\tvar bits_per_sample = 16;\n\n\t\tvar size_source_buffer = input_8_bit_int_buffer.length;\n\n\t\tvar new_32_bit_array = new Float32Array(input_8_bit_int_buffer.length / 2);\n\n\t\tvar max_int_value_seen = -99999999.9;\n\t\tvar min_int_value_seen =  99999999.9;\n\n\t\tvar max_float_value_seen = -99999999.9;\n\t\tvar min_float_value_seen =  99999999.9;\n\n\t\t// var tmp_16_bit_signed_int;\n\t\tvar tmp_16_bit_unsigned_int;\n\n\t\tvar value_16_bit_signed_int;\n\t\tvar index_32_bit_floats = 0;\n\n\t\tfor (var index = 0; index < size_source_buffer; index += 2, index_32_bit_floats++) {\n\n\t\t\t// tmp_16_bit_signed_int = (input_8_bit_int_buffer[index + 1] << 8) | input_8_bit_int_buffer[index];\n\t\t\ttmp_16_bit_unsigned_int = (input_8_bit_int_buffer[index + 1] << 8) | input_8_bit_int_buffer[index];\n\n\t\t\t// value_16_bit_signed_int = conv_bit_size(tmp_16_bit_signed_int, bits_per_sample);\n\t\t\tvalue_16_bit_signed_int = conv_bit_size(tmp_16_bit_unsigned_int, bits_per_sample);\n\n\t\t\t// console.log(\"tmp_16_bit_unsigned_int \", tmp_16_bit_unsigned_int, \n\t\t\t// \t\t   \" value_16_bit_signed_int \", value_16_bit_signed_int);\n\n\t\t\tif (value_16_bit_signed_int < min_int_value_seen) {\n\n\t\t\t\tmin_int_value_seen = value_16_bit_signed_int;\n\n\t\t\t} else if (value_16_bit_signed_int > max_int_value_seen) {\n\n\t\t\t\tmax_int_value_seen = value_16_bit_signed_int;\n\t\t\t}\n\n\t\t\t// ---\n\n\t\t    new_32_bit_array[index_32_bit_floats] = ((0 < value_16_bit_signed_int) ? \n\t\t    \t\t\t\t\t\t\t\t\t\t\t  value_16_bit_signed_int / 0x7FFF : \n\t\t    \t\t\t\t\t\t\t\t\t\t\t  value_16_bit_signed_int / 0x8000);\n\t\t\t// ---\n\n\t\t\tif (new_32_bit_array[index_32_bit_floats] < min_float_value_seen) {\n\n\t\t\t\tmin_float_value_seen = new_32_bit_array[index_32_bit_floats];\n\n\t\t\t} else if (new_32_bit_array[index_32_bit_floats] > max_float_value_seen) {\n\n\t\t\t\tmax_float_value_seen = new_32_bit_array[index_32_bit_floats];\n\t\t\t}\n\t\t}\n\n\t\t// console.log(\"max_int_value_seen \", max_int_value_seen, \" min_int_value_seen \", min_int_value_seen);\n\t\t// console.log(\"max_float_value_seen \", max_float_value_seen, \" min_float_value_seen \", min_float_value_seen);\n\n\t\treturn new_32_bit_array;\n\t};\n\n\t// ----------------------\n\n\tvar convert_32_bit_float_into_signed_16_bit_int_lossy = function(input_32_bit_buffer) {\n\n\t\t// this method is LOSSY - intended as preliminary step when saving audio into WAV format files\n\t\t//                        output is a byte array where the 16 bit output format \n\t\t//\t\t\t\t\t\t  is spread across two bytes in little endian ordering\n\n\t    var size_source_buffer = input_32_bit_buffer.length;\n\n\t    var buffer_byte_array = new Int16Array(size_source_buffer * 2); // Int8Array 8-bit twos complement signed integer\n\n\t    var value_16_bit_signed_int;\n\t    var index_byte = 0;\n\n\n\t    for (var index = 0; index < size_source_buffer; index++) {\n\n\t        value_16_bit_signed_int = ~~((0 < input_32_bit_buffer[index]) ? input_32_bit_buffer[index] * 0x7FFF : \n\t        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinput_32_bit_buffer[index] * 0x8000);\n\n\t        buffer_byte_array[index_byte] = value_16_bit_signed_int & 0xFF;\n\n\t        var byte_two_of_two = (value_16_bit_signed_int >> 8);\n\n\t        buffer_byte_array[index_byte + 1] = byte_two_of_two;\n\n\t        index_byte += 2;\n\t    }\n\n\t    // ---\n\n\t    return buffer_byte_array;\n\t};\n\t\t\t\n\t// ----------------------\n\n\tvar show_object = function (given_obj, given_label, given_mode, limit_size_buffer) {\n\n\t\tconsole.log(\"_______TOP show_object \", given_label, given_mode);\n\n\t\t// populate defaults if not supplied\n\t\t\n\t\tvar mode = given_mode || \"partial\";\n\t\tvar label = given_label || \"\";\n \n\t\tlimit_size_buffer = (limit_size_buffer === 0) ? 9999999999 : limit_size_buffer; // no limit if given 0 as limit\n\n\t\tvar size_buffer = limit_size_buffer;\n\n\t\tconsole.log(\"_______TOP limit_size_buffer \", limit_size_buffer);\n\t\tconsole.log(\"_______TOP size_buffer       \", size_buffer);\n\n\t\tvar property = null;\n\n\t\tif (\"partial\" == mode) {\n\n\t\t    for (property in given_obj) {\n\n\t\t        // console.log(given_label, \" property \", property);\n\t\t        console.log(given_label, \" property -->\" + property + \"<--\\t\", given_obj[property]);\n\t\t    }\n\n\t\t} else {\n\n\t\t    for (property in given_obj) {\n\n\t\t        // console.log(property, \"\\t property.substring(0,3) \\t\", property.substring(0,3));\n\n\t\t        if (property.substring(0,3) == \"cb_\") {\n\n\t\t        \t// console.log(given_label, property, \" ignoring callback\");\n\n\t\t        } else if (property == \"socket_conn\") {\n\n\t\t        \t// console.log(given_label, property, \" ignoring socket connection details\");\n\n\n\t\t        } else if (\"buffer\" == property || \n\t\t        \t   \"raw_buffer\" == property || \n\t\t  \"buffer_input_file_float\" == property || \n\t\t        \"buffer_input_file\" == property)   {\n\n\t\t        \t\tvar max_value_seen = -9999999, min_value_seen = 9999999;\n\n\t\t\t        \tconsole.log(given_label, \" about to show \", property);\n\t\t\t        \tconsole.log(given_label, property, \" of length \", given_obj[property].length);\n\n\t\t\t        \tvar local_min_size_buffer = (given_obj[property].length < size_buffer) ? \n\t\t\t        \t\t\t\t\t\t\t     given_obj[property].length : size_buffer;\n\n\t\t\t        \tvar local_max_size_buffer = local_min_size_buffer;\n\n\t\t\t        \tif (local_min_size_buffer === 0) {\n\n\t\t\t        \t\tlocal_max_size_buffer = given_obj[property].length;\n\t\t\t        \t}\n\n\t\t\t    \t\tfor (var index = 0; index < local_max_size_buffer; index++) {\n\n\t\t\t        \t\tconsole.log(given_label, property, \"\\t\", index, given_obj[property][index]);\n\n\t\t\t        \t\tmin_value_seen = (given_obj[property][index] < min_value_seen) ? \n\t\t\t        \t\t\t\t\t\t  given_obj[property][index] : min_value_seen;\n\t\t\t        \t\tmax_value_seen = (given_obj[property][index] > max_value_seen) ? \n\t\t\t        \t\t\t\t\t\t  given_obj[property][index] : max_value_seen;\n\t\t\t    \t\t}\n\t\t\t    \t\t// if (given_obj.buffer.length > local_size_buffer) {\n\t\t\t    \t\tif (given_obj[property].length > local_max_size_buffer) {\n\n\t\t\t        \t\tconsole.log(given_label, \"\\t....... \");\n\t\t\t    \t\t}\n\n\t\t\t        \tconsole.log(given_label, \" min_value_seen \", min_value_seen,\n\t\t\t        \t\t\t\t\t\t\t \" max_value_seen \", max_value_seen);\n\t\t    \t} else {\n\n\t\t    \t\t// if (typeof property === \"object\") {\n\t\t    \t\t// if (typeof given_obj[property] === \"object\") {\n\n\t\t    \t\t// \t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n\n\t\t    \t\t// \tconsole.log(\"cool seeing property \", property, \" IS typeof object so recurse\");\n\n\t\t    \t\t// \tshow_object(given_obj[property], given_label + \" \" + property, \n\t\t    \t\t// \t\t\t\tgiven_mode, limit_size_buffer);\n\n\t\t    \t\t// } else {\n\n\t\t        \t\tconsole.log(given_label, \" property -->\" + property + \"<--\\t\", given_obj[property]);\n\t\t    \t\t// }\n\t\t    \t}\n\t\t    }\n\t\t}\n\n\t\tconsole.log(\"_______ BOTTOM show_object \", given_label, given_mode, \" buffer size \",\n\t\t\t\t\tgiven_obj[property].length);\n\t};\n\n\t// ----------------------\n\n\tvar diff_entire_buffers = function(left_obj, right_obj, size_buffer, given_spec) {\n\n\t\tconsole.log(\"TOP of diff_entire_buffers\");\n\n\t\tvar total_diffs = 0;\n\t\tvar total_raw_left = 0;\n\t\tvar total_raw_right = 0;\n\n\t\tvar left_buffer = left_obj.buffer;\n\t\tvar right_buffer = right_obj.buffer;\n\n\t\tfor (var index = 0; index < size_buffer; index++) {\n\n\t\t\ttotal_diffs += Math.abs(left_buffer[index] - right_buffer[index]);\n\n\t\t\ttotal_raw_left  += Math.abs(left_buffer[index]);\n\t\t\ttotal_raw_right += Math.abs(right_buffer[index]);\n\t\t}\n\n\t\tconsole.log(\"total_diffs \", total_diffs);\n\n\t\tgiven_spec.total_diffs = total_diffs;\n\n\t\tgiven_spec.total_raw_left  = total_raw_left;\n\t\tgiven_spec.total_raw_right = total_raw_right;\n\t};\n\n\t// ---\n\n\tvar diff_buffers = function (left_obj, right_obj, given_spec) {\n\n\t\t// console.log(\"here is left_obj \", left_obj);\n\t\t// console.log(\"here is right_obj \", right_obj);\n\n\n\t\tvar extent = \"entire\";\t// default - diff which portions of buffers\n\t\tvar master = \"left\";\t// default - determines which buffer determines buffer length\n\n\t\tvar spec;\n\n\t    if (typeof given_spec === \"undefined\") {\n\n\t        console.log(\"seeing NO input spec so populating with defaults\");\n\n\t    \tspec = { \n\t\t\t\t\t\textent : extent,\t// diff which portions of buffers\n\t\t\t\t\t\tmaster : master,\t// determines which buffer determines buffer length\n\t\t\t\t\t};\n\t\t} else {\n\t        spec = given_spec;\n\t        console.log(\"seeing input spec \", spec);\n\t    }\n\n\t    if (typeof spec.extent !== \"undefined\") {\n\t        extent = spec.extent;\n\t        console.log(\"seeing input spec with spec.extent \", spec.extent);\n\t    }\n\n\t    if (typeof spec.master !== \"undefined\") {\n\t        master = spec.master;\n\t        console.log(\"seeing input spec with spec.master \", spec.master);\n\t    }\n\n\t    given_spec.extent = extent;\n\t    given_spec.master = master;\n\n\t    console.log(\"here is spec \", given_spec);\n\t    console.log(\"here is extent \", extent);\n\t    console.log(\"here is master \", master);\n\n\t    var size_buffer;\n\n        switch (master) {\n\n            case \"left\" : {\n\n                size_buffer = left_obj.buffer.length;\n                break;\n            }\n\n            case \"right\" : {\n\n                size_buffer = right_obj.buffer.length;\n                break;\n            }\n\n            // --- default - catch all if not identifed above\n\n            default :\n\n            console.error(\"ERROR - failed to find spec.master in diff_buffers\");\n            process.exit(8);\n\n            break;\n        }\n\n\t    console.log(\"size_buffer \", size_buffer);\n\t    console.log(\"size left   \", left_obj.buffer.length);\n\t    console.log(\"size right  \", right_obj.buffer.length);\n\n\t    if (size_buffer > left_obj.buffer.length || size_buffer > right_obj.buffer.length) {\n\n            throw new Error(\"ERROR - you defined master as : \", master, \n            \t\t\t  \" yet buffer size is larger than other buffer\");\n\t    }\n\n\t    spec.size_buffer = size_buffer;\n\n\t    // ---\n\n        switch (extent) {\n\n            case \"entire\" : {\n\n\t            console.log(\"OK extent is \", extent)    ;\n\n\t    \t\tdiff_entire_buffers(left_obj, right_obj, size_buffer, given_spec);\n\n\t    \t\tbreak;\n            }\n\n            default : {\n\n            \tthrow new Error(\"ERROR - failed to find recognized value of spec.extent : \", extent);\n            }\n        }\n\n\t    console.log(\"extent \", extent);\n\n\t};\n\nreturn {\n\n\tshow_object : show_object,\n\tdiff_buffers : diff_buffers,\n\tset_random_seed : set_random_seed,\n\tget_random_in_range_inclusive_float : get_random_in_range_inclusive_float,\n\tget_random_in_range_inclusive_int : get_random_in_range_inclusive_int,\n\trelease_all_prop_from_object : release_all_prop_from_object,\n\tconvert_32_bit_float_into_unsigned_16_bit_int_lossy : convert_32_bit_float_into_unsigned_16_bit_int_lossy,\n\tconvert_16_bit_unsigned_int_to_32_bit_float : convert_16_bit_unsigned_int_to_32_bit_float,\n\tconvert_16_bit_signed_int_to_32_bit_float : convert_16_bit_signed_int_to_32_bit_float,\n\tconvert_32_bit_float_into_signed_16_bit_int_lossy : convert_32_bit_float_into_signed_16_bit_int_lossy\n};\n\t\n}());\n\n","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/src/ww_client_socket.js":"\n\nvar ww_client_socket = (function() {      //      inside ww\n\n\"use strict\";\n\nvar cb_for_client = null;\nvar cb_stream_is_complete = null;\nvar cb_send_file_header = null;\n\n\n\nvar send_console_to_browser = (function() {\n// var console = (function() {\n\n    function getScriptName() {\n        var error = new Error();\n        var source = null;\n        var lastStackFrameRegex = new RegExp(/.+\\/(.*?):\\d+(:\\d+)*$/);\n        var currentStackFrameRegex = new RegExp(/getScriptName \\(.+\\/(.*):\\d+:\\d+\\)/);\n\n        if((source = lastStackFrameRegex.exec(error.stack.trim())) && source[1] !== \"\")\n            return source[1];\n        else if((source = currentStackFrameRegex.exec(error.stack.trim())))\n            return source[1];\n        else if(error.fileName !== undefined)\n            return error.fileName;\n    }\n\n    return {\n\n        log : function(given_str) {\n\n            var log_object = {\n\n                type: 'debug',\n                msg: common_utils.source() + given_str,\n                script_name : getScriptName()\n            };\n\n            self.postMessage(log_object);\n        }\n    };\n}());\n\n\n\n\nvar websocket_connection = (function() {\n\n\tvar web_socket = null;\n\tvar flag_connected = false;\n\tvar server_side_buffer_obj = {};\n\n    var MAX_CONN_RETRY = 1000;\n    var counter_retry_connection = 0;\n\n    var retry_delay_time = 5; // init with this number of miliseconds ... exponentially \n                              // increase upon hickups\n\n\n    var flag_connection_active = true; // start OK if closed then becomes false\n\n    if (! (\"WebSocket\" in self)) {\n\n        send_console_to_browser.log(\"ERROR - boo hoo ... websockets is not available on this browser - use firefox\");\n        return;\n    }\n\n    if (flag_connected) {\n\n    \t// throw new Error(\"ERROR - socket already connected ... zap this error msg\");\n        return; // already connected\n    }\n\n    send_console_to_browser.log(\"very cool web sockets are supported by your browser\");\n\n    var host = location.origin.replace(/^http/, 'ws');\n    web_socket = new WebSocket(host);\n\n\n    // console.log(\"Corinde alpha\");\n\n\n    // following binaryType must be set or you will get this error :\n    /* Uncaught TypeError: Failed to construct 'Blob': The 1st argument provided is either null, \n       or an invalid Array object.\n    */\n    web_socket.binaryType = \"arraybuffer\"; // stens TODO - added April 30 2014\n\n    // ---\n\n    web_socket.onconnection = function(stream) {\n        console.log('WebSocket connect');\n    };\n\n    web_socket.onconnected = function(stream) {\n        console.log('someone connected!');\n    };\n\n    web_socket.onmessage = function(event) {        //      receive message from server side\n\n        // console.log(\"top of onmessage\");\n\n        if (typeof event.data === \"string\") {\n\n            // console.log('String message received: ' + event.data);\n\n            var received_json = JSON.parse(event.data);\n\n        \t// console.log(\"RECEIVED --- \");\n         //    console.log(\"RECEIVED --- received_json \");\n         //    shared_utils.show_object(received_json, \"received_json string  \", \"total\", 3);\n         //    console.log(\"RECEIVED --- \");\n\n            // ---\n\n            if (typeof received_json.streaming_is_done !== \"undefined\") {\n\n                if (\"yes\" == received_json.streaming_is_done) {\n\n                    var local_max_index = received_json.max_index;\n\n                    console.log(\"OK received_json.streaming_is_done == yes  local_max_index \", \n                        local_max_index,\n                        \" ... so call cb_stream_is_complete \",  cb_stream_is_complete.name);\n\n                    cb_stream_is_complete(local_max_index);\n                }\n\n            } else if (typeof received_json.error_msg !== \"undefined\") {\n\n                console.log(received_json);\n\n                var error_msg = received_json.error_msg;\n                var requested_source = received_json.requested_source;\n\n                send_console_to_browser.log(error_msg + \"  \" + requested_source); // sent back to browser html\n\n            } else if (typeof received_json.sample_rate !== \"undefined\") {\n\n                // console.log(\"source media header info\");\n                // console.log(received_json);\n\n                // shared_utils.show_object(received_json, \"send_file_header  \", \"total\", 3);\n\n                cb_send_file_header(received_json);\n\n            } else if (typeof received_json.max_index !== \"undefined\") {\n\n                console.log(received_json); // stens TODO - ignore for now\n\n            } else if (typeof received_json.rss !== \"undefined\") {\n\n                // updateStats(received_json);    // put received data directly to browser screen\n\n            } else {\n\n                send_console_to_browser.log(\"ERROR - invalid JSON \");\n                send_console_to_browser.log(received_json);\n\n                // throw new Error(\"ERROR - invalid JSON \");\n            }\n\n        } else if (event.data instanceof ArrayBuffer) {\n\n            // console.log(\"RECEIVED --- \");\n            // console.log(\"RECEIVED --- ArrayBuffer received: \" + event.data);\n            // console.log(\"RECEIVED --- \");\n\n            server_side_buffer_obj.buffer = new Float32Array(event.data);\n\n            var server_buffer_len = server_side_buffer_obj.buffer.length;\n\n            // ---\n            /*\n            curr_buffer_index += server_buffer_len;\n\n            console.log(\"running            max_index \" + max_index);\n            console.log(\"running    curr_buffer_index \" + curr_buffer_index);\n\n            if (max_index && curr_buffer_index >= max_index) {\n\n                console.log(\"cool now deal            max_index \" + max_index);\n                console.log(\"cool now deal    curr_buffer_index \" + curr_buffer_index);\n            }\n            */\n\n            // ---\n\n            cb_for_client(server_side_buffer_obj);\n\n        } else if (event.data instanceof Blob) { // binary\n\n            console.log('Blob received on client browser side of length data.size ', event.data.size);\n\n            var size_buffer = event.data.size;\n\n            // var binary_bytes = new Uint8Array(e.data);\n            // var binary_bytes = new ArrayBuffer(e.data);\n            var server_buffer = new Blob(event.data);\n            // var image = context.createImageData(canvas.width, canvas.height);\n            // for (var i = 0; i < 200; i++) {\n\n            //     console.log(server_buffer[i]);\n            // }\n\n            // ---\n\n            for (var property in Blob) {\n\n                console.log(\"Blob property \", property, \" value \", Blob[property]);\n            }\n\n        } else {\n\n            console.error(\"ERROR - socket receieved Who Knows \", event.data);\n        }\n    };\n\n    web_socket.onerror = function(error_stream) {\n\n        send_console_to_browser.log('ERROR - fault on socket');\n\n        for (var curr_property in error_stream) {\n\n            if (error_stream.hasOwnProperty(curr_property)) {\n\n                send_console_to_browser.log(\"error property \" + \n                                curr_property + \" -->\" + error_stream[curr_property] +\n                                                \"<-- \");\n            }\n        }\n    };\n\n    // ---\n\n    // flag_connected = true; // stens TODO put this in correct callback above\n\n    web_socket.onclose = function(close_event) {\n\n        send_console_to_browser.log(\"NOTICE - onclose with message\");\n\n        flag_connection_active = false;\n\n        // console.log(close_event);\n\n        // shared_utils.show_object(close_event, \"ceoeoeoeoeoe   close_event  \", \"total\", 3);\n\n        for (var curr_property in close_event) {\n\n            if (close_event.hasOwnProperty(curr_property)) {\n\n                send_console_to_browser.log(\"curr_property \" + \n                                        curr_property + \" -->\" + close_event[curr_property] +\n                                                        \"<-- \");\n            }\n        }\n\n        var streaming_is_done_msg = {\n\n            streaming_is_done : \"yes\",\n            max_index : 0\n        };\n\n        send_console_to_browser.log(\"streaming_is_done_msg\");\n        send_console_to_browser.log(streaming_is_done_msg);\n\n        self.postMessage(streaming_is_done_msg);\n\n    };\n\n    web_socket.onopen = function(){\n\n        // send some message\n\n        send_console_to_browser.log(\"NOTICE - onopen just called\");\n\n        flag_connected = true; // stens TODO put this in correct callback above\n    };\n\n\n\treturn {\n\n\t\tinit : function() {\n\n\t\t},\n\t\tsend_request_to_server : (function() {\n\n\t            // below pair of functions act as a try / wait until web socket connection is ready\n\n\t\t    // see SO question\n\t\t    // Tornado WebSockets - InvalidStateError Still in CONNECTING State\n\t\t    // my error was \n\t\t    // InvalidStateError: Failed to execute 'send' on 'WebSocket': Still in CONNECTING state\n\t\t    // since I moved web socket init logic out of page reload\n\n\t\t    function wait_for_socket_connection(socket, callback) {\n\n\t\t        setTimeout(\n\t\t            function() {\n\n                        // console.log(\"Corinde beta\");\n\n\t\t                if (socket.readyState === 1) {\n\t\t                    if(callback !== undefined){\n\t\t                        callback();\n\t\t                    }\n\t\t                    return;\n\n\t\t                } else {\n\n\t\t                    console.log(\"... waiting for web socket connection to come online\");\n\n                            counter_retry_connection += 1;\n\n                            if (counter_retry_connection > MAX_CONN_RETRY) {\n\n                                var error_msg = \"ERROR - connection retry count limit reached\";\n\n                                console.log(error_msg);\n\n                                flag_connection_active = false;\n\n                                retry_delay_time *= 2; // exponentially increase delay time\n\n                                web_socket.close();\n\n                                cb_stream_is_complete(0); // intentionally stop \n                            }\n\n\t\t                    wait_for_socket_connection(socket,callback);\n\t\t                }\n\t\t            }, retry_delay_time);\n\t\t    }\n\n\t\t    function send_message(msg) {\n\n\t\t        wait_for_socket_connection(web_socket, function() {\n\n                    // console.log(\"SENDING ------ \");\n                    // console.log(msg);\n                    // console.log(\"SENDING ------ \");\n\n\t\t            web_socket.send(msg);\n\t\t        });\n\t\t    }\n\n\t\t    // -------------\n\n\t\t    var count_send_request = 0;\n\n\t\t    return function(given_msg) {\n\n\t\t        // console.log(\"[][][][][]  ..........  send_request_to_server\");\n\n\t\t        if (! flag_connected) {\n\n\t\t            send_console_to_browser.error(\"ERROR - no web socket connection\");\n\t\t            return;\n\t\t        }\n\n\t\t        var request_msg = JSON.stringify(given_msg);\n\n\t\t        // console.log(count_send_request , \" SEND -------- \");\n\t\t        // console.log(count_send_request , \" SEND -------- \", request_msg);\n\t\t        // console.log(count_send_request , \" SEND -------- \");\n                \n\t\t        count_send_request += 1;\n\n\t\t        send_message(request_msg);\n\t\t    };\n\t\t}()),\n        close_socket : function() {\n\n            send_console_to_browser.log(\"NOTICE - about to close socket intentionally\");\n\n            web_socket.close();\n\n        }\n\t};\n}());      //      websocket_connection\n\nvar set_send_file_header_cb = function(given_cb) {\n\n    // console.log(\"set_send_file_header_cb \" + given_cb.name);\n\n    cb_send_file_header = given_cb;\n};\n\nvar set_stream_is_complete_cb = function(given_cb_stream_is_complete) { // supplied by calling client\n\n    // console.log(\"now SET cb_stream_is_complete to \", given_cb_stream_is_complete.name);\n    \n    cb_stream_is_complete = given_cb_stream_is_complete; // when server side says stream is done this gets called\n};\n\nvar set_cb_for_client = function(given_callback) {\n\n    cb_for_client = given_callback;\n};\n\nvar socket_client = (function() {\n\n\twebsocket_connection.init();\n\n\treturn function(given_msg) {\n\n\t\t// console.log(\"socket_client  given_msg \", given_msg);\n\n        // shared_utils.show_object(given_msg, \"CCCCCCCCCCC   given_msg  \", \"total\", 3);\n\n\t    var given_mode = given_msg.mode;\n\n\t    // console.log(\"socket_client  given_mode \", given_mode);\n\n\t    switch (given_mode) {\n\n\t        case \"mode_stream_audio\" : {    //  stream audio buffer from server \n\n\t            // console.log('mode_stream_audio  Launch request to stream audio ////////');\n\n\n                // websocket_connection.close_socket(); // troubleshooting only\n\n\t            websocket_connection.send_request_to_server(given_msg);\n\n\t            break;\n\t        }\n\n\t        case \"mode_stop_streaming\" : {\n\n\t            console.log(\"mode_stop_streaming\");\n                console.log(given_msg);\n\n\t            websocket_connection.send_request_to_server(given_msg);\n\n\t            break;\n\t        }\n\n\t        default : {\n\n\t            throw new Error(\"ERROR - invalid mode : \" + given_mode);\n\t        }\n\t\t}\n\t};\n}());\n\nreturn {\n\n\tsocket_client : socket_client,\n\tset_cb_for_client : set_cb_for_client,\n\tset_stream_is_complete_cb : set_stream_is_complete_cb,\n    set_send_file_header_cb : set_send_file_header_cb\n};\n\n}());\t//\tww_client_socket","/home/travis/build/npmtest/node-npmtest-websockets-streaming-audio/node_modules/websockets-streaming-audio/src/ww_transferable_obj.js":"\nimportScripts('common_utils.js');\nimportScripts('shared_utils.js');\nimportScripts('ww_client_socket.js');\n\n// ---------------------------------- //\n\n// function log(msg) {\n\n// \t// var object = {\n// \t// \ttype: 'debug',\n// \t// \tmsg: common_utils.source() + msg + ' [' + common_utils.time() + ']'\n// \t// };\n\n// \tvar object = {\n// \t\ttype: 'debug',\n// \t\tmsg: common_utils.source() + msg\n// \t};\n\n//   self.postMessage(object);\n// }\n\n\n\n// var console = (function() {\n\n//     return {\n\n//         log : function(given_str) {\n\n//             send_console_to_browser(given_str);\n//         }\n//     };\n// }());\n\n\n\nvar send_console_to_browser = (function() {\n// var console = (function() {\n\n    function getScriptName() {\n        var error = new Error();\n        var source = null;\n        var lastStackFrameRegex = new RegExp(/.+\\/(.*?):\\d+(:\\d+)*$/);\n        var currentStackFrameRegex = new RegExp(/getScriptName \\(.+\\/(.*):\\d+:\\d+\\)/);\n\n        if((source = lastStackFrameRegex.exec(error.stack.trim())) && source[1] !== \"\")\n            return source[1];\n        else if((source = currentStackFrameRegex.exec(error.stack.trim())))\n            return source[1];\n        else if(error.fileName !== undefined)\n            return error.fileName;\n    }\n\n    return {\n\n        log : function(given_str) {\n\n\t\t\tvar log_object = {\n\n\t\t\t\ttype: 'debug',\n\t\t\t\tmsg: common_utils.source() + given_str,\n\t\t\t\tscript_name : getScriptName()\n\t\t\t};\n\n\t\t\tself.postMessage(log_object);\n        }\n    };\n}());\n\n\n\n\n// ---\n\nvar manage_buffer_processing = (function() {\n\n\tvar curr_mode_send_to_browser_or_ww = null;\n\n\treturn {\n\n\t\tset_mode : function(given_mode) {\n\n\t\t\tcurr_mode_send_to_browser_or_ww = given_mode;\n\n\t\t\t// console.log(\"manage_buffer_processing\");\n\t\t\t// console.log(curr_mode_send_to_browser_or_ww);\n\t\t},\n\t\tget_mode : function() {\n\n\t\t\treturn curr_mode_send_to_browser_or_ww;\n\t\t}\n\t};\n}());\n\nfunction send_to_ww_queue(given_audio_obj_from_server) {\n\n    var curr_buffer_obj = {};\n\n\tcurr_buffer_obj.buffer = new Float32Array(given_audio_obj_from_server.buffer);\n\n\tvar size_buffer = curr_buffer_obj.buffer.length;\n\n\t// console.log(\"ww TOP send_to_browser_queue length \" + size_buffer);\n\n\t// for (var i = 0; i < size_buffer; i++) {\n\n\t// \tcurr_buffer_obj.buffer[i] = given_audio_obj_from_server.buffer[i];\n\n\t// \t// if (i < 1) {\n\t// \t// \tconsole.log(\"cb \" + float_array[i]);\n\t// \t// }\n\t// }\n\n    queue_first_in_first_out.push(curr_buffer_obj);\n\n    // ---\n\n\tif (queue_first_in_first_out.is_production_possible()) {\n\n\t\tvar msgs_to_server = manage_message.get_msg().mode_stream_audio_to_client;\n\n\t\t// shared_utils.show_object(msgs_to_server, \"ggggggggggggggg msgs_to_server\", \"total\", 10);\n\n\t\tww_client_socket.socket_client(msgs_to_server);\n\n    } else {\n\n    \t// console.log(\"at this point ww queue is full and browser is consuming its own queue\");\n    \t// console.log(\"when browser queue drains to min threshold then browser will consume\");\n    \t// console.log(\"ww queue until browser queue is full at which point it toggles back into\");\n    \t// console.log(\"mode where ww queue gets filled by server ... yet once again\");\n    }\n}\n\nfunction send_to_browser_queue(given_audio_obj) {\n\n\t// var size_buffer = given_audio_obj.buffer.length;\n\n\t// * Float32Array.BYTES_PER_ELEMENT\n\n\t// console.log(given_audio_obj);\n\n\t// array_buffer = new ArrayBuffer(given_audio_obj.buffer.byteLength);\n\t// float_array = new Float32Array(array_buffer);\n\tvar float_array = new Float32Array(given_audio_obj.buffer);\n\n\tvar size_buffer = float_array.length;\n\n\t// console.log(\"ww TOP send_to_browser_queue length \" + size_buffer);\n\n\t// for (var i = 0; i < size_buffer; i++) {\n\n\t// \tfloat_array[i] = given_audio_obj.buffer[i];\n\n\t// \t// if (i < 1) {\n\t// \t// \tconsole.log(\"cb \" + float_array[i]);\n\t// \t// }\n\t// }\n\n\t// console.log(\"cb \" + float_array[0]);\n\n\tself.postMessage(float_array.buffer, [float_array.buffer]); // sending array back to browser\n}\n\nfunction cb_receive_buffer_from_server(given_audio_obj_from_server) {\n\n\tvar curr_mode = manage_buffer_processing.get_mode();\n\n\t// console.log(\"cb_receive_buffer_from_server \" + curr_mode);\n\n\tswitch (curr_mode) {\n\n\t\tcase \"ww_get_audio_from_server\" : {\n\n\t\t\tsend_to_ww_queue(given_audio_obj_from_server);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase \"browser_get_audio_from_ww\" : {\n\n\t\t\tsend_to_ww_queue(given_audio_obj_from_server);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase \"browser_get_audio_from_server\" : {\n\n\t\t\tsend_to_browser_queue(given_audio_obj_from_server);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault : {\n\n\t\t\tthrow new Error(\"ERROR - invalid cb for buffer from server : \" + curr_mode);\n\t\t}\n\t}\n}\n\nfunction cb_send_file_header(given_json_obj) {\n\n\t// console.log(\"sending file header back to browser\");\n\n\tself.postMessage(JSON.stringify(given_json_obj));\n}\n\nfunction cb_stream_is_complete(given_max_index) {\n\n\tsend_console_to_browser.log(\"cb_stream_is_complete ... given_max_index \" + given_max_index);\n\n\t// bbbbbbbbbbbb\n\n\tqueue_first_in_first_out.set_max_index(given_max_index);\n\tqueue_first_in_first_out.set_streaming_is_done();\n\n\tself.postMessage(JSON.stringify({\n\t\tww_directed_mode : \"streaming_is_done\",\n\t\tmax_index : given_max_index\n\t}));\n}\n\nvar queue_first_in_first_out = (function() { // first in first out queue\n\n\t// console.log(\"iiiiiiiiiiiiii  TOP queue_first_in_first_out\");\n\n    var queue_first_in_first_out_obj = {};\n    var push_index = 0;\n    var pop_index = 0;\n    var curr_size_ww_queue = 0;    // number of entries currently in queue\n    var max_size_ww_queue = null;   // maximum queue size\n\n    var streaming_is_done = false; // supplied only after end of source media has been reached\n    var max_index = null;          // supplied only after end of source media has been reached\n\n    return {\n\n        is_production_possible : function() {\n\n        \t// console.log(\"INNN is_production_possible max_size_ww_queue \" + max_size_ww_queue +\n        \t// \t\" ... curr_size_ww_queue \" + curr_size_ww_queue + \n        \t// \t\"   ANSWER \" + (curr_size_ww_queue < max_size_ww_queue));\n\n        \t// console.log(\"kkkkkkkkkkkkkkkkk    is_WW_production_possible ... curr_size_ww_queue \" + \n        \t// \t\t\tcurr_size_ww_queue + \"  \" + (curr_size_ww_queue < max_size_ww_queue));\n\n            return (curr_size_ww_queue < max_size_ww_queue);\n            // return ((curr_size_ww_queue < max_size_ww_queue) ? true : false);\n        },\n        push : function(given_audio_obj_from_server) { // execute production\n\n            // if (! queue_first_in_first_out.is_production_possible()) {\n\n            //     throw new Error(\"ERROR - called push when production is NOT possible\");\n            //     return;\n            // }\n\n            // console.log(\"curr_size_ww_queue \", curr_size_ww_queue, \n            // \t\t  \"   max_size_ww_queue \", max_size_ww_queue);\n\n            queue_first_in_first_out_obj[push_index] = given_audio_obj_from_server;\n\n            push_index += 1;\n            curr_size_ww_queue += 1;   // increment queue size\n\n            // console.log(\"OK push ... curr_size_ww_queue \", curr_size_ww_queue);\n        },\n        is_consumption_possible : function() {\n\n        \t// console.log(\"toooooooooooooop is_WW_consumption_possible ... curr_size_ww_queue \" + \n        \t// \t\t\tcurr_size_ww_queue + \"   \" + (curr_size_ww_queue > 0));\n\n            return (curr_size_ww_queue > 0);\n        },\n        pop : function() {\t// execute consumption\n\n            if (! queue_first_in_first_out.is_consumption_possible()) {\n\n                throw new Error(\"ERROR - called pop when consumption is NOT possible\");\n            }\n\n            if (pop_index > 0) {\n\n                delete queue_first_in_first_out_obj[pop_index - 1]; // destroy previously consumed entry\n\n                // console.log(\"about to delete queue_first_in_first_out_obj ... pop_index \", pop_index - 1);\n            }\n\n            if (pop_index < push_index) {\n\n                curr_size_ww_queue -= 1;   // decrement queue size\n\n                // log(\"WW queue  \" + curr_size_ww_queue);\n\n                console.log(\"WW queue  \" + curr_size_ww_queue);\n\n                return (queue_first_in_first_out_obj[pop_index++]);\n            }\n        },\n        set_max_size_ww_queue : function(given_max_size_ww_queue) {\n\n            max_size_ww_queue = given_max_size_ww_queue;\n\n            console.log(\"set_max_size_ww_queue    max_size_ww_queue  \", max_size_ww_queue);\n        },\n        set_max_index : function(given_max_index) {\n\n        \tmax_index = given_max_index;\n        },\n        set_streaming_is_done : function() {\n\n        \tstreaming_is_done = true;\n        },\n        get_streaming_is_done : function() {\n\n        \treturn streaming_is_done;\n        }\n        // get_curr_size_ww_queue : function() {\n\n        // \treturn curr_size_ww_queue;\n        // }\n        // get_max_size_ww_queue : function() {\n\n        // \treturn max_size_ww_queue;\n        // }\n    };\n})();       //      queue_first_in_first_out\n\nvar manage_message = (function() {\n\n\tvar msgs_to_server = null;\n\n\treturn {\n\n\t\tset_msg : function(given_msgs_to_server) {\n\n\t\t\tmsgs_to_server = given_msgs_to_server;\n\n\t\t\t// console.log(\"msgs_to_server \" + msgs_to_server);\n\t\t},\n\t\tget_msg : function() {\n\n\t\t\treturn msgs_to_server;\n\t\t}\n\t};\n}());\n\nvar setup_stream_audio_from_server = function(msgs_to_server) {\n\n\t// console.log(\"tttttttttttttt setup_stream_audio_from_server ............................\");\n\n\n    // shared_utils.show_object(msgs_to_server, \"ooooooooooooooooooooo  msgs_to_server \", \"total\", 10);\n\n\n\n\tmanage_message.set_msg(msgs_to_server);\n\n\tww_client_socket.set_cb_for_client(cb_receive_buffer_from_server);\n\n\tww_client_socket.set_stream_is_complete_cb(cb_stream_is_complete);\n\n\tww_client_socket.set_send_file_header_cb(cb_send_file_header);\n\n\tqueue_first_in_first_out.set_max_size_ww_queue(msgs_to_server.mode_stream_audio_to_client.ww_queue_max_size);\n\n\t// console.log(\"bbbbbbbbbbbbb setup_stream_audio_from_server ............................\");\n};\n\nfunction drain_ww_queue_send_to_browser() {\n\n\tif (! queue_first_in_first_out.is_consumption_possible()) {\n\n\t\tif (queue_first_in_first_out.get_streaming_is_done()) {\n\n\t\t\tconsole.log(\"streaming_is_done and ww queue is empty so just return\");\n\n\t\t\t// bbbbbbbbbb  link flag_connection_active from client socket to\n\t\t\t//\t\tavoid loop\n\n\t\t\treturn;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tsend_to_browser_queue(queue_first_in_first_out.pop());\n}\n\nself.onmessage = function(event) {\t//    retrieved a message from browser\n\n\tif (typeof event.data === \"string\") {\n\n\t\t// console.log(event.data);\n\n\t\tvar received_json = JSON.parse(event.data);\n\n\t\t// shared_utils.show_object(received_json, \"WWWWWWWWWWWW received_json\", \"total\", 10);\n\n\t\tif (typeof received_json.browser_directed_mode !== \"undefined\") {\n\n\t\t\t// console.log(\"received_json.browser_directed_mode \" + received_json.browser_directed_mode);\n\n\t\t\tswitch (received_json.browser_directed_mode) { // mode 3\n\n\t\t\t\tcase \"browser_get_audio_from_ww\" : {\n\n\t\t\t\t\tmanage_buffer_processing.set_mode(received_json.browser_directed_mode);\n\n\t\t\t\t\tdrain_ww_queue_send_to_browser();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase \"ww_get_audio_from_server\" : { // mode 2\n\n\t\t\t\t\t// stens TODO - flip callback which retrieves data from server\n\n\t\t\t\t\t// console.log(\"wswswswswswswswswsws    ww_get_audio_from_server\");\n\n\t\t\t\t\tmanage_buffer_processing.set_mode(received_json.browser_directed_mode);\n\n\t\t\t\t\tif (queue_first_in_first_out.is_production_possible()) {\n\n\t\t\t\t\t\tww_client_socket.socket_client(received_json);\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// console.log(\"booo hoo is_production_possible says NNNOOOOOOOOOOO\");\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase \"browser_get_audio_from_server\" : { // mode 1\n\n\t\t\t\t\t// console.log(\"bsbs bsbsbsbs bsbsbsbs bsbs    browser_get_audio_from_server\");\n\n\t\t\t\t\t// -----------\n\n\t\t\t\t\t// for (var curr_property in received_json) {\n\n\t\t\t\t\t// \tif (received_json.hasOwnProperty(curr_property)) {\n\n\t\t\t\t\t// \t\tconsole.log(\"received_json property \" + curr_property);\n\t\t\t\t\t// \t}\n\t\t\t\t\t// }\n\n\t\t\t\t\t// ------------\n\n\t\t\t\t\tmanage_buffer_processing.set_mode(received_json.browser_directed_mode);\n\n\t\t\t\t\t// ---\n\n// mode_stop_streaming              MIGHT need to do below to THIS mode as well\n// mode_stream_audio_to_client\n\n\t\t\t\t\tvar msgs_to_server = manage_message.get_msg();\n\n\t\t\t\t\tvar specific_mode_stream = msgs_to_server.mode_stream_audio_to_client;\n\t\t\t\t\tvar specific_mode_stop   = msgs_to_server.mode_stop_streaming;\n\n\t\t\t\t\tspecific_mode_stream.request_number   = received_json.request_number;\n\t\t\t\t\tspecific_mode_stream.requested_source = received_json.requested_source;\n\t\t\t\t\t\n\t\t\t\t\tspecific_mode_stop.request_number   = received_json.request_number;\n\t\t\t\t\tspecific_mode_stop.requested_source = received_json.requested_source;\n\n\t\t\t\t\tmsgs_to_server.mode_stream_audio_to_client = specific_mode_stream;\n\t\t\t\t\tmsgs_to_server.mode_stop_streaming = specific_mode_stop;\n\n\t\t\t\t\tmanage_message.set_msg(msgs_to_server);\n\n\t\t\t\t\t// ---\n\n\t\t\t\t\t// ww_client_socket.socket_client(\n\t\t\t\t\t// \tmanage_message.get_msg().mode_stream_audio_to_client);\n\n\t\t\t\t\tww_client_socket.socket_client(received_json);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase \"setup_stream_audio_from_server\" : {\n\n\t\t\t\t\tsetup_stream_audio_from_server(received_json);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase \"mode_stop_streaming\" : {\n\n\t\t\t\t\tconsole.log(\"momomomomomomomomomomo     mode_stop_streaming\");\n\n\t\t\t\t\tww_client_socket.socket_client(\n\t\t\t\t\t\tmanage_message.get_msg().mode_stop_streaming);\n\n\t\t\t\t\t// --- reset to prepare for next media --- //\t\t\t\t\t\n\n\t\t\t\t\tmanage_buffer_processing.set_mode(\"browser_get_audio_from_server\");\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdefault : {\n\n\t\t\t\t\tsend_console_to_browser.log(\"ERROR - invalid browser_directed_mode : \" + \n\t\t\t\t\t\t\t\t\treceived_json.browser_directed_mode);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsend_console_to_browser.log(\"ERROR - ww did receive string from browser\" +\n\t\t\t\t\t\t\"... yet NOT seeing browser_directed_mode\");\n\t\t}\n\n\t} else {\n\n\t\tsend_console_to_browser.log(\"ERROR - ww received NON string from browser\" +\n\t\t\t\t\t\"... maybe event.data instanceof ArrayBuffer \");\n\t}\n};\n"}